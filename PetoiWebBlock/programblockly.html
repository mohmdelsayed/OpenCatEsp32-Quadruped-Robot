<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Petoi Web Coding Blocks</title>
  <link rel="icon" href="./assets/logo.svg" type="image/svg+xml" />
  <!-- 1. 首先加载 Blockly 核心文件 -->
  <script src="./node_modules/blockly/blockly_compressed.js"></script>
  <script src="./node_modules/blockly/blocks_compressed.js"></script>
  <script src="./node_modules/blockly/javascript_compressed.js"></script>
  <!-- 2. 语言文件改为动态加载 -->
  <!-- <script src="./node_modules/blockly/msg/zh-hans.js"></script> -->
  <!-- <script src="./node_modules/blockly/msg/en.js"></script> -->
  <!-- 3. 加载自定义翻译 -->
  <script src="./lang/translations.js"></script>
  <!-- 4. 加载超时配置 -->
  <script src="./js/timeout_config.js"></script>
  <!-- 5. 然后加载自定义积木块文件 -->
  <script src="./blocks/communication.js"></script>
  <script src="./blocks/generators.js"></script>
  <!-- 6. 加载 WebSocket 客户端 -->
  <script src="./js/petoi_async_client.js"></script>
  <script src="./js/toolbox.js"></script>
  <link rel="stylesheet" href="./styles.css">
</head>

<body>
  <div class="header">
    <div class="title" data-i18n="appTitle">Petoi Web Coding Blocks</div>
    <div class="header-right">
      <div class="version-date" id="versionDate"></div>
      <div class="language-switch">
        <button id="zhBtn" class="lang-btn" onclick="setLanguage('zh')">中文</button>
        <button id="enBtn" class="lang-btn active" onclick="setLanguage('en')">English</button>
        <button id="jaBtn" class="lang-btn" onclick="setLanguage('ja')">日本語</button>
      </div>
    </div>
  </div>
  <div class="container">
    <div class="button-group">
      <button onclick="showCode()" data-i18n="showCode">Show Code</button>
      <button onclick="runCode()" data-i18n="runCode">Run Code</button>
      <button onclick="stopCode()" id="stopCodeBtn" data-i18n="stopCode" style="display: none;">Stop Code</button>
      <button onclick="saveWorkspace()" data-i18n="saveProgram">Save Program</button>
      <button onclick="document.getElementById('loadInput').click()" data-i18n="loadProgram">Load Program</button>
      <button onclick="triggerSkillFileUpload()" data-i18n="uploadSkills">Upload Skills</button>
      <input type="file" id="skillFileInput" accept=".md" multiple onchange="handleSkillFilesUpload(this.files)"
        style="display: none;">
      <button onclick="generateLog()" data-i18n="generateLog">Generate Log</button>
      <button onclick="clearWorkspace()" data-i18n="clearAll">Clear All</button>
      <input type="file" id="loadInput" accept=".json" onchange="loadWorkspace(this.files[0])">
      <span id="currentFileLabel" data-i18n="currentFileLabel" style="margin-left: 10px; color: #555;"></span>
      <span id="currentFileName" style="color: #555; font-style: italic;"></span>
      <div class="right-aligned-container">
        <button onclick="quickConnect()" id="quickConnectBtn" data-i18n="quickConnect">Quick Connect</button>
      </div>
    </div>

    <div class="workspace-container">
      <div id="blocklyDiv"></div>
      <div class="resizer" id="divider"></div>
      <div class="windows-container">
        <div id="skillFilesContainer"
          style="display: none; margin-bottom: 10px; padding: 10px; background-color: #f5f5f5; border-radius: 4px;">
          <h4 style="margin: 0 0 10px 0;" data-i18n="uploadedSkills">Uploaded Skills</h4>
          <div id="skillFilesList" style="max-height: 150px; overflow-y: auto;"></div>
        </div>
        <div id="consoleWindow">
          <div class="area-header">
            <span class="area-title" data-i18n="consoleLog">Console Log</span>
            <div class="button-group">
              <button id="showTimestampBtn" onclick="toggleShowTimestamp()" class="toggle-button active"
                data-i18n="showTimestamp">Timestamp</button>
              <button id="showSentCommandsBtn" onclick="toggleShowSentCommands()" class="toggle-button"
                data-i18n="showSentCommands">Show Commands</button>
              <button id="showDebugBtn" onclick="toggleShowDebug()" class="toggle-button"
                data-i18n="showDebug">Debug</button>
              <button onclick="clearConsole()" class="clear-button" data-i18n="clearLog">Clear Log</button>
            </div>
          </div>
          <div id="consoleLog" class="dark-scrollbar"></div>
        </div>
        <!-- 添加水平分隔线，用于调整控制台和串口区域的高度比例 -->
        <div class="horizontal-resizer" id="console-serial-divider"></div>
        <!-- 添加串口通信相关的HTML结构 -->
        <div id="serialContainer">
          <div class="area-header">
            <span class="area-title" id="serialOutputTitle" data-i18n="serialOutput">Serial Monitor</span>
            <div class="button-group">
              <button onclick="openSerialPort()" class="serial-button" id="openSerialBtn"
                data-i18n="serialConnect">Connect Serial Port</button>
              <button id="showSerialTimestampBtn" onclick="toggleShowSerialTimestamp()" class="toggle-button active"
                style="display: none;" data-i18n="showTimestamp">Timestamp</button>
              <button onclick="closeSerialPort()" class="clear-button" id="closeSerialBtn" style="display: none;"
                data-i18n="closeSerial">Close Connection</button>
              <button onclick="clearSerialOutput()" class="clear-button" id="clearSerialBtn" style="display: none;"
                data-i18n="clearLog">Clear Log</button>
            </div>
          </div>
          <div id="serialInterface" style="display: none;">
            <div class="serial-output dark-scrollbar" id="serialOutput"></div>
            <div class="serial-input-container">
              <input type="text" id="serialInput" placeholder="Enter content to send"
                data-i18n="serialInputPlaceholder">
              <button onclick="sendSerialData()" class="serial-button" data-i18n="send">Send</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // 自定义主题
    // 将函数设为全局可用
    window.PetoiAsyncClient = PetoiAsyncClient;

    // 初始化变量
    var workspace;

    // 当前语言
    let isChangingLanguage = false;
    // save entry block ids
    let startBlockIds = [];

    // 新增翻译助手函数
    function getText(key)
    {
      return TRANSLATIONS[currentLang][key] || key;
    }

    // 获取格式化的时间戳 [HH:MM:SS.mmm]
    function getFormattedTimestamp()
    {
      const now = new Date();
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');
      const seconds = String(now.getSeconds()).padStart(2, '0');
      const milliseconds = String(now.getMilliseconds()).padStart(3, '0');
      return `[${hours}:${minutes}:${seconds}.${milliseconds}]`;
    }

    // 设置版本日期
    function setVersionDate()
    {
      const versionElement = document.getElementById('versionDate');
      if (versionElement)
      {
        // 使用当前日期作为版本日期
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        versionElement.textContent = `v${year}.${month}.${day}`;
      }
    }

    // 加载配置文件
    async function loadConfig()
    {
      try
      {
        // 首先尝试从localStorage加载配置
        const localStorageConfig = localStorage.getItem('petoiConfig');
        if (localStorageConfig)
        {
          try
          {
            const parsedConfig = JSON.parse(localStorageConfig);
            config = { ...config, ...parsedConfig };
            if (typeof showDebug !== 'undefined' && showDebug)
            {
              console.log('Configuration loaded from localStorage:', config);
            }
            return; // 如果从localStorage成功加载，就不需要从文件加载了
          } catch (parseError)
          {
            console.warn('Failed to parse localStorage config:', parseError);
            // 如果解析失败，继续尝试从文件加载
          }
        }

        // 如果localStorage中没有配置或解析失败，使用默认配置
        if (typeof showDebug !== 'undefined' && showDebug)
        {
          console.log('No localStorage config found, using default configuration');
        }
      } catch (error)
      {
        console.warn('Failed to load config, using defaults:', error);
      }
    }

    // 保存配置文件
    async function saveConfig()
    {
      try
      {
        // 更新连接历史
        if (currentDeviceIP && currentDeviceIP !== config.lastKnownIP)
        {
          config.lastKnownIP = currentDeviceIP;
          config.lastConnectedTime = new Date().toISOString();

          // 添加到连接历史（最多保存10个）
          if (!config.connectionHistory.includes(currentDeviceIP))
          {
            config.connectionHistory.unshift(currentDeviceIP);
            config.connectionHistory = config.connectionHistory.slice(0, 10);
          }
        }

        // 保存到localStorage，这样页面刷新后配置不会丢失
        try
        {
          localStorage.setItem('petoiConfig', JSON.stringify(config));
          if (typeof showDebug !== 'undefined' && showDebug)
          {
            console.log('Configuration saved to localStorage:', config);
          }
        } catch (localStorageError)
        {
          console.warn('Failed to save to localStorage:', localStorageError);
        }

        // 注意：由于浏览器安全限制，无法直接写入文件
        // 这里只是更新内存中的配置，实际保存需要服务器端支持
        if (typeof showDebug !== 'undefined' && showDebug)
        {
          console.log('Configuration updated:', config);
        }
      } catch (error)
      {
        console.error('Failed to save config:', error);
      }
    }

    // 尝试使用配置的IP地址连接
    async function tryConnectWithConfigIP()
    {
      if (!config.lastKnownIP)
      {
        if (typeof showDebug !== 'undefined' && showDebug)
        {
          console.log('No configured IP address available');
        }
        return false;
      }

      // 如果当前IP就是配置的IP，说明已经连接成功，不需要重复连接
      if (currentDeviceIP === config.lastKnownIP)
      {
        if (typeof showDebug !== 'undefined' && showDebug)
        {
          console.log(`Already connected to configured IP: ${config.lastKnownIP}`);
        }

        // 确保按钮显示正确的IP地址
        updateQuickConnectButtonState(currentDeviceIP);
        if (typeof showDebug !== 'undefined' && showDebug)
        {
          console.log(`Updated Quick Connect button to show IP: ${currentDeviceIP}`);
        }

        return true;
      }

      if (typeof showDebug !== 'undefined' && showDebug)
      {
        console.log(`Trying to connect with configured IP: ${config.lastKnownIP}`);
      }

      try
      {
        // 尝试使用配置的IP地址创建WebSocket连接
        const testClient = new PetoiAsyncClient(`ws://${config.lastKnownIP}:81`);
        await testClient.connect();

        // 如果连接成功，更新当前IP地址
        currentDeviceIP = config.lastKnownIP;
        if (typeof showDebug !== 'undefined' && showDebug)
        {
          console.log(`Successfully connected with configured IP: ${currentDeviceIP}`);
        }

        // 更新Quick Connect按钮状态
        updateQuickConnectButtonState(currentDeviceIP);

        // 更新配置中的连接时间并保存
        config.lastConnectedTime = new Date().toISOString();
        await saveConfig();
        if (typeof showDebug !== 'undefined' && showDebug)
        {
          console.log('Configuration updated with successful connection:', config);
        }

        // 更新make_connection积木中的IP地址
        const makeConnectionBlocks = workspace.getBlocksByType('make_connection');
        if (makeConnectionBlocks && makeConnectionBlocks.length > 0)
        {
          // 更新第一个make_connection积木块的IP_ADDRESS字段
          makeConnectionBlocks[0].setFieldValue(currentDeviceIP, 'IP_ADDRESS');
          if (typeof showDebug !== 'undefined' && showDebug)
          {
            console.log(`Updated make_connection block IP to: ${currentDeviceIP}`);
          }
        }

        return true;
      } catch (error)
      {
        if (typeof showDebug !== 'undefined' && showDebug)
        {
          console.log(`Failed to connect with configured IP ${config.lastKnownIP}:`, error);
        }
        return false;
      }
    }

    // 更新自定义积木的定义
    function updateCustomBlockDefinitions()
    {
      // 更新所有工作区中的积木
      if (workspace)
      {
        // 使用根块优先的方式处理
        // 1. 首先找出所有没有父块的根积木
        const rootBlocks = workspace.getTopBlocks(true);

        // 2. 递归处理每个根积木及其子积木
        rootBlocks.forEach(rootBlock =>
        {
          updateBlockAndChildren(rootBlock);
        });
      }

      // 定义递归更新块和其子块的函数
      function updateBlockAndChildren(block)
      {
        if (block.type === 'make_connection' ||
          block.type === 'get_digital_input' ||
          block.type === 'get_analog_input' ||
          block.type === 'get_sensor_input' ||
          block.type === 'set_digital_output' ||
          block.type === 'set_analog_output' ||
          block.type === 'send_custom_command' ||
          block.type === 'console_input' ||
          block.type === 'delay_ms' ||
          block.type === 'posture' ||
          block.type === 'gait' ||
          block.type === 'acrobatic_moves' ||
          block.type === 'set_motor_angle' ||
          block.type === 'get_joint_angle' ||
          block.type === 'get_all_joint_angles' ||
          block.type === 'gyro_control' ||
          block.type === 'console_log_variable')
        {
          // 保存原有字段值
          const fieldValues = {};
          for (let i = 0; i < block.inputList.length; i++)
          {
            const input = block.inputList[i];
            for (let j = 0; j < input.fieldRow.length; j++)
            {
              const field = input.fieldRow[j];
              if (field.name)
              {
                fieldValues[field.name] = field.getValue();
              }
            }
          }

          // 保存位置信息
          const position = block.getRelativeToSurfaceXY();

          // 保存连接信息 - 包括所有输入连接
          const savedConnections = [];

          // 保存下一个块的连接
          if (block.nextConnection && block.nextConnection.isConnected())
          {
            savedConnections.push({
              type: 'next',
              connection: block.nextConnection.targetConnection
            });
          }

          // 保存所有输入连接
          for (let i = 0; i < block.inputList.length; i++)
          {
            const input = block.inputList[i];
            if (input.connection && input.connection.isConnected())
            {
              savedConnections.push({
                type: 'input',
                name: input.name,
                connection: input.connection.targetConnection
              });
            }
          }

          // 清空输入列表，避免积木元素堆叠
          block.inputList = [];

          // 重新初始化积木
          const initFunc = Blockly.Blocks[block.type].init;
          if (initFunc)
          {
            initFunc.call(block);

            // 恢复字段值
            for (const name in fieldValues)
            {
              const field = block.getField(name);
              if (field)
              {
                field.setValue(fieldValues[name]);
              }
            }

            // 恢复位置 - 只对根块有效
            if (!block.getParent())
            {
              const newPosition = block.getRelativeToSurfaceXY();
              block.moveBy(position.x - newPosition.x, position.y - newPosition.y);
            }

            // 重新渲染以确保视觉正确
            block.initSvg();
            block.render();
          }

          // 延迟恢复连接，确保所有块都已更新
          setTimeout(() =>
          {
            // 恢复所有保存的连接
            savedConnections.forEach(savedConn =>
            {
              if (savedConn.type === 'next')
              {
                if (block.nextConnection && savedConn.connection)
                {
                  block.nextConnection.connect(savedConn.connection);
                }
              } else if (savedConn.type === 'input')
              {
                const input = block.getInput(savedConn.name);
                if (input && input.connection && savedConn.connection)
                {
                  input.connection.connect(savedConn.connection);
                }
              }
            });
          }, 0);
        }

        // 递归处理所有子块
        if (block.nextConnection && block.nextConnection.targetBlock())
        {
          updateBlockAndChildren(block.nextConnection.targetBlock());
        }

        // 处理所有输入连接的子块
        for (let i = 0; i < block.inputList.length; i++)
        {
          const input = block.inputList[i];
          if (input.connection && input.connection.targetBlock())
          {
            updateBlockAndChildren(input.connection.targetBlock());
          }
        }
      }
    }

    // 保存当前工作区的积木
    function saveCurrentWorkspace()
    {
      return Blockly.serialization.workspaces.save(workspace);
    }

    // 恢复工作区积木
    function restoreWorkspace(state)
    {
      Blockly.serialization.workspaces.load(state, workspace);
    }

    function initWorkspace()
    {
      // 创建新的工具箱配置，确保使用新语言
      blocklyGlobalConfig();
      const newToolbox = createToolbox();
      workspace = Blockly.inject('blocklyDiv', {
        media: './node_modules/blockly/media/',
        toolbox: newToolbox,
        theme: customTheme,
        grid: {
          spacing: 20,
          length: 3,
          colour: '#ccc',
          snap: true
        },
        zoom: {
          controls: true,
          wheel: true,
          startScale: 1.0,
          maxScale: 3,
          minScale: 0.3,
          scaleSpeed: 1.2
        },
        trashcan: true
      });

      // 监听工作区变化事件
      workspace.addChangeListener(handleWorkspaceEvent);
    }

    // 切换语言
    function setLanguage(lang)
    {
      if (isChangingLanguage || currentLang === lang) return;
      isChangingLanguage = true;

      // 更新按钮样式
      document.getElementById('zhBtn').classList.toggle('active', lang === 'zh');
      document.getElementById('enBtn').classList.toggle('active', lang === 'en');
      document.getElementById('jaBtn').classList.toggle('active', lang === 'ja');

      // 保存当前工作区状态
      const workspaceState = saveCurrentWorkspace();

      // 加载相应语言文件
      loadLanguageFile(lang, function ()
      {
        // 设置当前语言
        currentLang = lang;

        // 重新注入工作区
        workspace.dispose();

        initWorkspace();

        // 恢复工作区状态
        restoreWorkspace(workspaceState);

        // 再次更新自定义积木
        updateCustomBlockDefinitions();

        // 更新撤销和重做按钮状态
        updateUndoRedoState();

        // 更新UI文本
        updateUITranslations();

        isChangingLanguage = false;
      });
    }

    // 初始化时设置默认语言为英文
    window.addEventListener('DOMContentLoaded', function ()
    {
      // 确保先动态加载英文语言文件，再进行其他初始化
      loadLanguageFile('en', function ()
      {
        // 设置当前语言为英文
        currentLang = 'en';

        initWorkspace();

        // 初始化自定义积木
        updateCustomBlockDefinitions();

        // 更新UI文本
        updateUIText();

        // 设置版本日期
        setVersionDate();

        if (typeof window.updateUITranslations === 'function')
        {
          window.updateUITranslations();
        }

        // 添加窗口大小变化事件监听器
        window.addEventListener('resize', resizeBlocklyWorkspace);

        // 设置初始宽度比例
        const container = document.querySelector('.workspace-container');
        const blocklyDiv = document.getElementById('blocklyDiv');
        const windowsContainer = document.querySelector('.windows-container');

        blocklyDiv.style.flexBasis = '70%';
        blocklyDiv.style.width = '70%';
        windowsContainer.style.flexBasis = '29%'; // 减去分隔线宽度
        windowsContainer.style.width = '29%';

        // 初始调整工作区大小
        resizeBlocklyWorkspace();
        // 添加撤销和重做按钮
        addUndoRedoButtons();
        resetWorkspace();

        // 更新按钮状态
        document.getElementById('zhBtn').classList.toggle('active', false);
        document.getElementById('enBtn').classList.toggle('active', true);
        document.getElementById('jaBtn').classList.toggle('active', false);

        // 加载配置文件
        loadConfig();
      });

      // 添加控制台和串口输出区域的键盘复制功能
      function setupCopyKeyboardShortcuts()
      {
        // 控制台区域复制功能
        const consoleLogElement = document.getElementById('consoleLog');
        // 设置tabindex，使元素可以接收键盘事件
        consoleLogElement.setAttribute('tabindex', '0');

        consoleLogElement.addEventListener('keydown', function (e)
        {
          // 检测Ctrl+C或Command+C (Mac)
          if ((e.ctrlKey || e.metaKey) && e.key === 'c')
          {
            const selectedText = window.getSelection().toString();
            if (selectedText)
            {
              navigator.clipboard.writeText(selectedText)
                .then(() => {/* 移除复制成功消息 */ })
                .catch(err => console.error(getText("copyFailed"), err));
            }
          }
        });

        // 使控制台区域可以通过点击获得焦点
        consoleLogElement.addEventListener('click', function ()
        {
          this.focus();
        });

        // 串口输出区域复制功能
        const serialOutputElement = document.getElementById('serialOutput');
        // 设置tabindex，使元素可以接收键盘事件
        serialOutputElement.setAttribute('tabindex', '0');

        serialOutputElement.addEventListener('keydown', function (e)
        {
          // 检测Ctrl+C或Command+C (Mac)
          if ((e.ctrlKey || e.metaKey) && e.key === 'c')
          {
            const selectedText = window.getSelection().toString();
            if (selectedText)
            {
              navigator.clipboard.writeText(selectedText)
                .then(() => {/* 移除复制成功消息 */ })
                .catch(err => console.error(getText("copyFailed"), err));
            }
          }
        });

        // 使串口输出区域可以通过点击获得焦点
        serialOutputElement.addEventListener('click', function ()
        {
          this.focus();
        });
      }

      // 初始化复制功能
      setupCopyKeyboardShortcuts();

      // 移除旧的checkbox事件监听器，现在使用按钮点击事件
    });

    function handleWorkspaceEvent(event)
    {
      // console.log('workspace event', event);
      // 当工作区被清空时，添加默认积木块
      if (event.type === Blockly.Events.FINISHED_LOADING)
      {
        resetWorkspace();
      }

      // 更新撤销和重做按钮状态
      updateUndoRedoState();
    }
    // 添加动态加载语言文件的辅助函数
    function loadLanguageFile(lang, callback)
    {
      const script = document.createElement('script');
      script.onload = function ()
      {
        if (typeof callback === 'function')
        {
          callback();
        }
      };

      // 根据语言选择对应的Blockly语言文件
      const langMap = {
        'zh': './node_modules/blockly/msg/zh-hans.js',
        'en': './node_modules/blockly/msg/en.js',
        'ja': './node_modules/blockly/msg/ja.js'
        // 可以在这里添加更多语言
      };
      script.src = langMap[lang] || langMap['en']; // 默认使用英文

      // 标记并添加新脚本
      script.setAttribute('data-language-script', 'true');
      document.head.appendChild(script);
    }

    // 更新UI文本的函数
    function updateUIText()
    {
      // 调用translations.js中的updateUITranslations函数
      if (typeof window.updateUITranslations === 'function')
      {
        window.updateUITranslations();
      }

      // 更新当前文件名显示
      const currentFileNameSpan = document.getElementById('currentFileName');
      const currentFileLabelSpan = document.getElementById('currentFileLabel');

      if (currentFileLabelSpan)
      {
        // 只在有文件时显示标签
        currentFileLabelSpan.style.display = currentFile ? 'inline' : 'none';
      }

      if (currentFileNameSpan && currentFile)
      {
        currentFileNameSpan.textContent = currentFile.name;
      } else if (currentFileNameSpan)
      {
        currentFileNameSpan.textContent = '';
      }

      // 如果串口已连接，更新串口监视器标题以保持端口信息
      if (port)
      {
        const serialTitle = document.getElementById('serialOutputTitle');
        if (serialTitle)
        {
          const displayName = getSerialPortDisplayName(port);
          serialTitle.textContent = getText("serialMonitorTitle").replace("{portName}", displayName);
        }
      }

      // 更新timestamp按钮的翻译文本
      const timestampBtn = document.getElementById('showTimestampBtn');
      const serialTimestampBtn = document.getElementById('showSerialTimestampBtn');
      if (timestampBtn)
      {
        timestampBtn.textContent = getText("showTimestamp");
      }
      if (serialTimestampBtn)
      {
        serialTimestampBtn.textContent = getText("showTimestamp");
      }
    }

    // 窗口大小变化时调整Blockly工作区
    function resizeBlocklyWorkspace()
    {
      // 在下一个事件循环中执行，确保DOM已更新
      setTimeout(function ()
      {
        if (workspace)
        {
          // 确保工作区和控制台区域的宽度比例保持不变
          const container = document.querySelector('.workspace-container');
          const blocklyDiv = document.getElementById('blocklyDiv');
          const windowsContainer = document.querySelector('.windows-container');

          // 如果没有显式设置宽度，则应用默认比例
          if (!blocklyDiv.style.width || !windowsContainer.style.width)
          {
            const containerWidth = container.getBoundingClientRect().width;
            blocklyDiv.style.flexBasis = '70%';
            blocklyDiv.style.width = '70%';
            windowsContainer.style.flexBasis = '29%'; // 减去分隔线宽度
            windowsContainer.style.width = '29%';
          }

          Blockly.svgResize(workspace);

          // 在调整工作区大小后重新定位撤销重做按钮
          repositionUndoRedoButtons();
        }
      }, 0);
    }

    // 定位撤销重做按钮的函数
    function repositionUndoRedoButtons()
    {
      const undoRedoControls = document.querySelector('.undoRedoControls');
      if (!undoRedoControls) return;

      // 获取放大缩小按钮容器
      const zoomControls = document.querySelector('.blocklyZoom');

      if (zoomControls)
      {
        const zoomRect = zoomControls.getBoundingClientRect();

        // 将撤销重做按钮与缩放控件在同一条竖线上
        undoRedoControls.style.right = (window.innerWidth - zoomRect.right) + 'px'; // 与放大缩小按钮右对齐
        undoRedoControls.style.top = (zoomRect.top - 70) + 'px'; // 放在放大缩小按钮上方
      }
    }

    // 添加默认的connect with IP积木块
    function addDefaultConnectionBlock()
    {
      // 只有当工作区不存在startBlockId时才添加默认积木
      if (startBlockIds.length == 0)
      {
        // 创建make_connection积木块
        const connectionBlock = workspace.newBlock('make_connection');
        // 设置IP地址为当前设备IP
        connectionBlock.setFieldValue(currentDeviceIP, 'IP_ADDRESS');
        // 初始化积木块(确保所有连接点正确设置)
        connectionBlock.initSvg();
        // 渲染积木块
        connectionBlock.render();
        // 将积木块移动到合适的位置
        connectionBlock.moveBy(50, 50);

        // init gyro_control block, set gyro_control block to disable, connect gyro_control block to connection block
        const gyroControlBlock = workspace.newBlock('gyro_control');
        gyroControlBlock.setFieldValue("0", 'STATE');
        gyroControlBlock.initSvg();
        gyroControlBlock.render();
        gyroControlBlock.moveBy(50, 50);
        connectionBlock.nextConnection.connect(gyroControlBlock.previousConnection);
        connectionBlock.setDeletable(false);
        gyroControlBlock.setDeletable(false);
        workspace.clearUndo();
        startBlockIds.push(connectionBlock.id);
        startBlockIds.push(gyroControlBlock.id);
      }
    }

    // 添加清空工作区的函数
    function clearWorkspace()
    {
      //delete all blocks except make_connection and gyro_control
      const blocksToDelete = workspace.getAllBlocks().filter(block => !startBlockIds.includes(block.id));
      blocksToDelete.forEach(block =>
      {
        try
        {
          block.dispose();
        } catch (e)
        {
        }
      });
      updateUndoRedoState();
    }

    function resetWorkspace()
    {
      addDefaultConnectionBlock();
      // workspace.clearUndo();
      updateUndoRedoState();
    }

    function showCode()
    {
      Blockly.JavaScript.INFINITE_LOOP_TRAP = null;

      // 修改：查找工作区中的'make_connection'积木块（Connect with IP）
      const makeConnectionBlocks = workspace.getBlocksByType('make_connection');

      // 如果没有找到make_connection积木块，显示错误信息
      if (makeConnectionBlocks.length === 0)
      {
        console.error(getText("noConnectionBlockError") || "错误：请添加一个'Connect with IP'积木块并将代码连接在其下方！");
        alert(getText("noConnectionBlockError") || "错误：请添加一个'Connect with IP'积木块并将代码连接在其下方！");
        return;
      }

      // 如果找到多个make_connection积木块，使用第一个
      const mainBlock = makeConnectionBlocks[0];

      // 准备一个临时的工作区，只包含我们要运行的代码
      const tempWorkspace = new Blockly.Workspace();

      // 复制主块及其所有连接的块到临时工作区
      // 先克隆主块
      const clonedMainBlock = Blockly.serialization.blocks.save(mainBlock);
      Blockly.serialization.blocks.append(clonedMainBlock, tempWorkspace);

      // 生成临时工作区的代码
      var code = Blockly.JavaScript.workspaceToCode(tempWorkspace);

      // 清理临时工作区
      tempWorkspace.dispose();

      // 创建蒙版背景
      var overlay = document.createElement('div');
      overlay.style.position = 'fixed';
      overlay.style.top = '0';
      overlay.style.left = '0';
      overlay.style.width = '100%';
      overlay.style.height = '100%';
      overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
      overlay.style.zIndex = '1200';  // 提高z-index值，高于控件
      overlay.style.display = 'flex';
      overlay.style.justifyContent = 'center';
      overlay.style.alignItems = 'center';

      // 点击蒙版时关闭对话框
      overlay.addEventListener('click', function (event)
      {
        if (event.target === overlay)
        {
          document.body.removeChild(overlay);
        }
      });

      // 创建一个包含代码的对话框
      var codeDialog = document.createElement('div');
      codeDialog.className = 'code-dialog';
      codeDialog.style.position = 'relative';
      codeDialog.style.backgroundColor = '#282c34';
      codeDialog.style.color = '#abb2bf';
      codeDialog.style.padding = '20px';
      codeDialog.style.borderRadius = '8px';
      codeDialog.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.5)';
      codeDialog.style.zIndex = '1201';  // 比overlay高1
      codeDialog.style.maxWidth = '90%';
      codeDialog.style.maxHeight = '80%';
      codeDialog.style.overflow = 'auto';
      codeDialog.style.fontFamily = '"Consolas", "Monaco", "Microsoft YaHei", "PingFang SC", "SimHei", sans-serif';

      // 标题
      var titleBar = document.createElement('div');
      titleBar.style.display = 'flex';
      titleBar.style.justifyContent = 'space-between';
      titleBar.style.alignItems = 'center';
      titleBar.style.marginBottom = '15px';

      var title = document.createElement('h3');
      // 使用getText函数获取翻译文本
      title.innerHTML = getText("generatedJSCode");
      title.style.margin = '0';
      title.style.color = '#e6e6e6';
      title.style.fontFamily = '"Microsoft YaHei", "PingFang SC", "SimHei", "Arial", sans-serif';

      var closeButton = document.createElement('button');
      closeButton.textContent = '×';
      closeButton.style.background = 'none';
      closeButton.style.border = 'none';
      closeButton.style.color = '#e6e6e6';
      closeButton.style.fontSize = '24px';
      closeButton.style.cursor = 'pointer';
      closeButton.onclick = function ()
      {
        document.body.removeChild(overlay);
      };

      titleBar.appendChild(title);
      titleBar.appendChild(closeButton);
      codeDialog.appendChild(titleBar);

      // 格式化代码
      // 1. 分割每行
      var codeLines = code.split('\n');

      // 2. 创建代码显示区域
      var codeContainer = document.createElement('pre');
      codeContainer.style.margin = '0';
      codeContainer.style.overflow = 'auto';
      codeContainer.style.backgroundColor = '#282c34';
      codeContainer.style.padding = '10px';
      codeContainer.style.borderRadius = '4px';
      codeContainer.style.lineHeight = '1.5';
      codeContainer.style.maxHeight = '60vh';
      codeContainer.style.fontSize = '14px';
      codeContainer.style.color = '#e6e6e6'; // 设置代码文本颜色

      // 添加自定义滚动条样式
      codeContainer.style.scrollbarWidth = 'thin';
      codeContainer.style.scrollbarColor = '#4d4d4d #282c34';

      // 添加整个代码块的文本，而不是逐行添加
      codeContainer.textContent = code;

      codeDialog.appendChild(codeContainer);

      // 添加复制按钮
      var copyButton = document.createElement('button');
      copyButton.innerHTML = getText("copyCode");
      copyButton.style.marginTop = '15px';
      copyButton.style.padding = '6px 12px';
      copyButton.style.backgroundColor = '#4d78cc';
      copyButton.style.color = 'white';
      copyButton.style.border = 'none';
      copyButton.style.borderRadius = '4px';
      copyButton.style.cursor = 'pointer';
      copyButton.style.fontFamily = '"Microsoft YaHei", "PingFang SC", "SimHei", "Arial", sans-serif';
      copyButton.onclick = function ()
      {
        navigator.clipboard.writeText(code).then(function ()
        {
          copyButton.innerHTML = getText("copySuccess");
          setTimeout(function ()
          {
            copyButton.innerHTML = getText("copyCode");
          }, 2000);
        });
      };

      codeDialog.appendChild(copyButton);
      overlay.appendChild(codeDialog);
      document.body.appendChild(overlay);

      // 添加ESC键监听
      function handleEscKey(event)
      {
        if (event.key === 'Escape')
        {
          document.body.removeChild(overlay);
          document.removeEventListener('keydown', handleEscKey);
        }
      }
      document.addEventListener('keydown', handleEscKey);
    }

    // 防抖变量
    let lastRunCodeTime = 0;
    let programStartTime = 0; // 程序启动时间
    let isProgramRunning = false;
    let stopExecution = false; // 全局停止标志

    // IP地址格式验证函数
    function isValidIPAddress(ip)
    {
      if (!ip || typeof ip !== 'string')
      {
        return false;
      }

      // 检查是否为192.168.4.1
      if (ip === '192.168.4.1')
      {
        return false; // 返回false表示需要quick connect
      }

      // 检查IP地址格式
      const ipRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
      return ipRegex.test(ip);
    }

    function runCode()
    {
      const now = Date.now();

      // 防抖检查：如果距离上次程序结束小于1秒，则不执行
      if (now - lastRunCodeTime < 1000)
      {
        if (typeof showDebug !== 'undefined' && showDebug)
        {
          console.log(getText("debounceTimeInterval"));
        }
        return;
      }

      // 检查程序是否正在运行
      if (isProgramRunning)
      {
        if (typeof showDebug !== 'undefined' && showDebug)
        {
          console.log(getText("debounceProgramRunning"));
        }
        return;
      }

      // 获取积木中的IP地址
      const makeConnectionBlocks = workspace.getBlocksByType('make_connection');
      let blockIP = '192.168.4.1'; // 默认IP

      if (makeConnectionBlocks.length > 0)
      {
        const mainBlock = makeConnectionBlocks[0];
        blockIP = mainBlock.getFieldValue('IP_ADDRESS') || '192.168.4.1';
      }

      // 检查积木中的IP地址是否需要自动执行quick connect
      if (!isValidIPAddress(blockIP))
      {
        if (typeof showDebug !== 'undefined' && showDebug)
        {
          console.log(getText("detectedInvalidIP").replace('{ip}', blockIP));
        }
        quickConnect().then(() =>
        {
          // quick connect完成后，延迟1秒再执行runCode
          setTimeout(() =>
          {
            executeRunCode();
          }, 1000);
        }).catch((error) =>
        {
          console.error("Quick connect失败:", error);
          // 即使quick connect失败，也尝试执行runCode
          executeRunCode();
        });
        return;
      }

      // 直接执行runCode
      executeRunCode();
    }

    function stopCode()
    {
      if (isProgramRunning)
      {
        const now = Date.now();

        // 防抖检查：如果距离程序启动小于1秒，则不执行停止
        if (now - programStartTime < 1000)
        {
          if (typeof showDebug !== 'undefined' && showDebug)
          {
            console.log(getText("stopDebounceTimeInterval") || "Stop button debounce: Please wait at least 1 second after program start");
          }
          return;
        }

        stopExecution = true;
        console.log(getText("stopRequested"));

        // 清理控制台输入界面
        if (typeof clearConsoleInput === 'function')
        {
          clearConsoleInput();
        }
      }
    }

    function executeRunCode()
    {
      const now = Date.now();
      programStartTime = now; // 记录程序启动时间
      isProgramRunning = true;
      stopExecution = false; // 重置停止标志

      // 显示停止按钮，隐藏运行按钮，并设置停止按钮为红色背景
      const stopBtn = document.getElementById('stopCodeBtn');
      stopBtn.style.display = 'inline-block';
      stopBtn.style.backgroundColor = '#ff4444';
      stopBtn.style.color = 'white';
      document.querySelector('button[onclick="runCode()"]').style.display = 'none';

      console.log(getText("programExecutionStarted"));

      window.LoopTrap = 1000;
      Blockly.JavaScript.INFINITE_LOOP_TRAP =
        'if (--window.LoopTrap < 0) throw "无限循环";\n';

      // 查找工作区中的'make_connection'积木块（Connect with IP）
      const makeConnectionBlocks = workspace.getBlocksByType('make_connection');

      if (makeConnectionBlocks.length === 0)
      {
        console.error(getText("noConnectionBlockError") || "错误：请添加一个'Connect with IP'积木块并将代码连接在其下方！");
        alert(getText("noConnectionBlockError") || "错误：请添加一个'Connect with IP'积木块并将代码连接在其下方！");
        isProgramRunning = false;
        return;
      }

      const mainBlock = makeConnectionBlocks[0];
      const tempWorkspace = new Blockly.Workspace();
      const clonedMainBlock = Blockly.serialization.blocks.save(mainBlock);
      Blockly.serialization.blocks.append(clonedMainBlock, tempWorkspace);
      var code = Blockly.JavaScript.workspaceToCode(tempWorkspace);
      tempWorkspace.dispose();
      Blockly.JavaScript.INFINITE_LOOP_TRAP = null;

      // 替换所有 console.log 为 asyncLog
      code = code.replace(/console\.log\((.*?)\);/g, 'await asyncLog($1);');

      // 包装整个代码到一个异步函数中
      const runCodeBlock = `
function asyncLog(message) {
  return new Promise((resolve) => {
    console.log(message);
    setTimeout(resolve, 0);
  });
}

// 检查停止标志的函数
function checkStopExecution() {
  if (stopExecution) {
    throw new Error("程序执行被用户停止");
  }
}

// 改进的循环停止检查函数
function checkStopExecutionInLoop() {
  if (stopExecution) {
    throw new Error("程序执行被用户停止");
  }
  // 给其他任务执行的机会，包括停止检查
  return new Promise(resolve => setTimeout(resolve, 0));
}

(async function () {
  try {
    checkStopExecution();
    
${code}

    checkStopExecution();
    // 程序结束时自动发送休息指令'd'
    await asyncLog(getText("programEndingRestCommand"));
    await webRequest("d", 5000, true);
  } catch (e) {
    if (e.message === "程序执行被用户停止") {
      // 只在catch块中打印一次停止消息，避免重复
      await asyncLog(getText("programExecutionStopped"));
      // 程序被用户停止时，立即发送休息指令'd'（在关闭连接之前）
      try {
        await asyncLog(getText("programEndingRestCommand"));
        await webRequest("d", 5000, true, null, true); // 绕过停止标志检查
        console.log("Rest command sent successfully");
      } catch (restError) {
        console.error(getText("restCommandFailed") + restError.message);
      }
    } else {
      console.error(getText("restCommandFailed") + e.message);
    }
  }
  await closeConnection();
  console.log(getText("taskEnded"));
})().catch((e) => {
  if (e.message === "程序执行被用户停止") {
    // 停止消息已在try-catch中处理，这里不需要重复打印
    // console.log(getText("programExecutionStopped"));
  } else {
    console.error(getText("networkRequestError") + ": " + e.message);
    alert(getText("networkRequestError") + ": " + e.message);
  }
}).finally(() => {
  // 程序执行完成后，重置运行状态
  isProgramRunning = false;
  stopExecution = false;
  
  // 记录程序结束时间，用于防抖
  lastRunCodeTime = Date.now();
  
  // 隐藏停止按钮，显示运行按钮，并重置停止按钮样式
  const stopBtn = document.getElementById('stopCodeBtn');
  stopBtn.style.display = 'none';
  stopBtn.style.backgroundColor = '';
  stopBtn.style.color = '';
  document.querySelector('button[onclick="runCode()"]').style.display = 'inline-block';
  
  // 清理控制台输入界面
  if (typeof clearConsoleInput === 'function') {
    clearConsoleInput();
  }
  
  console.log(getText("programExecutionCompleted"));
});
`
      try
      {
        eval(runCodeBlock);
      } catch (e)
      {
        console.info("code:");
        console.info(runCodeBlock);
        console.error(getText("networkRequestError") + ": " + e.message);
        alert(getText("networkRequestError") + ": " + e.message);
        // 发生错误时也要重置运行状态和按钮样式
        isProgramRunning = false;
        const stopBtn = document.getElementById('stopCodeBtn');
        stopBtn.style.display = 'none';
        stopBtn.style.backgroundColor = '';
        stopBtn.style.color = '';
        document.querySelector('button[onclick="runCode()"]').style.display = 'inline-block';
      }
    }

    function saveWorkspace()
    {
      // 显示保存对话框，提供保存和另存为选项
      promptSaveOptions();
    }

    function promptSaveOptions()
    {
      // 创建蒙版背景
      var overlay = document.createElement('div');
      overlay.className = 'overlay';

      // 创建对话框
      var dialog = document.createElement('div');
      dialog.className = 'wifi-dialog';
      dialog.style.maxWidth = '400px';

      // 使用getText获取本地化文本
      const title = getText('saveProgram');
      const message = currentFile ?
        getText('currentFile').replace('{filename}', currentFile.name) :
        getText('noFileSaved');
      const saveText = getText('save');
      const saveAsText = getText('saveAs');
      const cancelText = getText('cancel');
      const warningText = getText('saveWarning');

      dialog.innerHTML = `
        <h3>${title}</h3>
        <p>${message}</p>
        <p style="color: #999; font-size: 12px;">${warningText}</p>
      <div style="text-align: center; margin: 20px 0;">
        ${currentFile ?
          `<button onclick="saveFile('${currentFile.name}'); closeSaveOptionsDialog();" class="confirm" style="margin-right: 10px;">
              ${saveText}
            </button>` : ''}
        <button onclick="saveFileWithPrompt(); closeSaveOptionsDialog();" class="confirm" style="margin-right: 10px;">
          ${saveAsText}
        </button>
        <button onclick="closeSaveOptionsDialog()" class="cancel">
          ${cancelText}
        </button>
      </div>
    `;

      document.body.appendChild(overlay);
      document.body.appendChild(dialog);
    }

    function closeSaveOptionsDialog()
    {
      const dialog = document.querySelector('.wifi-dialog');
      const overlay = document.querySelector('.overlay');
      if (dialog) dialog.remove();
      if (overlay) overlay.remove();
    }

    function saveFile(filename)
    {
      // 创建工作区状态对象
      let workspaceState = Blockly.serialization.workspaces.save(workspace);
      workspaceState.skills = window.uploadedSkills;
      workspaceState.startBlockIds = startBlockIds; // 保存startBlockIds

      const blob = new Blob([JSON.stringify(workspaceState, null, 2)], { type: 'application/json' });

      let a = document.createElement('a');
      a.download = filename;
      a.href = URL.createObjectURL(blob);
      a.click();

      // 显示保存成功消息
      showSaveSuccessDialog(filename);
    }

    function saveFileWithPrompt()
    {
      // 显示默认文件名
      let defaultName = 'program.json';
      if (currentFile)
      {
        defaultName = currentFile.name;
      }

      // 提示用户输入文件名
      const fileName = prompt(
        getText("enterFileName"),
        defaultName
      );

      if (fileName)
      {
        // 添加.json扩展名（如果用户没有输入）
        let finalName = fileName;
        if (!finalName.toLowerCase().endsWith('.json'))
        {
          finalName += '.json';
        }

        // 保存文件
        saveFile(finalName);

        // 更新当前文件名
        currentFile = {
          name: finalName,
          lastModified: new Date().getTime()
        };

        // 更新显示的文件名和标签
        updateUIText();
      }
    }

    function showSaveSuccessDialog(fileName)
    {
      // 创建蒙版背景
      var overlay = document.createElement('div');
      overlay.className = 'overlay';

      // 创建对话框
      var dialog = document.createElement('div');
      dialog.className = 'wifi-dialog';
      dialog.style.maxWidth = '450px';

      // 使用getText函数获取本地化文本
      const title = getText("saveSuccess");
      const message = getText("savedToDownloads");
      const fileNameNote = getText("filenameNote").replace("{filename}", fileName);
      const closeText = getText("close");

      dialog.innerHTML = `
      <h3 style="color: #4CAF50;">${title}</h3>
      <p>${message}</p>
      <p style="margin-top: 10px; font-size: 14px;">${fileNameNote}</p>
      <div style="text-align: center; margin: 20px 0;">
        <button onclick="closeSuccessDialog()" class="confirm">
          ${closeText}
        </button>
      </div>
    `;

      document.body.appendChild(overlay);
      document.body.appendChild(dialog);
    }

    function closeSuccessDialog()
    {
      const dialog = document.querySelector('.wifi-dialog');
      const overlay = document.querySelector('.overlay');
      if (dialog) dialog.remove();
      if (overlay) overlay.remove();
    }

    // 存储上传的技能文件
    window.uploadedSkills = [];

    function triggerSkillFileUpload()
    {
      const skillFileInput = document.getElementById('skillFileInput');
      skillFileInput.value = null;
      skillFileInput.click();
    }

    // 处理技能文件上传
    function handleSkillFilesUpload(files)
    {
      if (!files || files.length === 0) return;

      let successCount = 0;
      let failCount = 0;
      let processedCount = 0;

      for (let i = 0; i < files.length; i++)
      {
        const file = files[i];
        handleSkillFileUpload(file, (success) =>
        {
          if (success)
          {
            successCount++;
          } else
          {
            failCount++;
          }
          processedCount++;

          // 当所有文件都处理完成后，显示统计信息
          if (processedCount === files.length)
          {
            if (successCount > 0)
            {
              console.info([getText("skillFilesUploaded").replace("{count}", successCount)]);
            }
            if (failCount > 0)
            {
              console.error([getText("skillFilesUploadFailed").replace("{count}", failCount)]);
            }
          }
        });
      }
    }

    // 处理单个技能文件上传
    function handleSkillFileUpload(file, callback)
    {
      if (!file)
      {
        if (callback) callback(false);
        return;
      }

      const reader = new FileReader();
      reader.onload = function (e)
      {
        try
        {
          // 解析技能文件内容
          const skillData = parseSkillFile(e.target.result);

          // 存储解析后的数据,如果文件名已存在，则覆盖
          const existingSkill = uploadedSkills.find(skill => skill.name === file.name);
          if (existingSkill)
          {
            existingSkill.content = skillData;
          } else
          {
            uploadedSkills.push({
              name: file.name,
              content: skillData
            });
          }

          // 更新文件列表显示
          updateSkillFilesList();

          // 显示成功消息
          console.info([getText("skillFileUploaded").replace("{filename}", file.name)]);

          if (callback) callback(true);
        } catch (err)
        {
          console.error([getText("skillFilesUploadFailed").replace("{filename}", file.name)]);
          if (callback) callback(false);
        }
      };
      reader.readAsText(file);
    }

    // 解析技能文件内容
    function parseSkillFile(content)
    {
      // 移除所有空行和注释
      const lines = content.split('\n')
        .map(line => line.trim())
        .filter(line => line && !line.startsWith('//'));

      // 查找token行
      const tokenLine = lines.find(line => line.startsWith('# Token'));
      if (!tokenLine)
      {
        throw new Error('未找到Token');
      }
      const token = lines[lines.indexOf(tokenLine) + 1].trim();

      // 查找data数组
      const dataStartIndex = lines.findIndex(line => line.startsWith('# Data'));
      if (dataStartIndex === -1)
      {
        throw new Error('未找到Data');
      }

      // 解析data数组
      const dataLines = lines.slice(dataStartIndex + 1);
      let data = [];

      for (const line of dataLines)
      {
        // 跳过空行和注释
        if (!line || line.startsWith('#')) continue;

        // 移除行首尾的大括号和空格
        const cleanLine = line.replace(/[{}]/g, '').trim();
        if (!cleanLine) continue;

        // 分割数字并转换为整数
        const numbers = cleanLine.split(',')
          .map(num => parseInt(num.trim()))
          .filter(num => !isNaN(num));

        if (numbers.length > 0)
        {
          data.push(numbers);
        }
      }

      return {
        token: token,
        data: data
      };
    }

    // 更新技能文件列表显示
    function updateSkillFilesList()
    {
      const container = document.getElementById('skillFilesContainer');
      const list = document.getElementById('skillFilesList');

      if (uploadedSkills.length === 0)
      {
        container.style.display = 'none';
        return;
      }

      container.style.display = 'block';
      list.innerHTML = '';

      uploadedSkills.forEach((skill, index) =>
      {
        const item = document.createElement('div');
        item.style.padding = '5px';
        item.style.borderBottom = '1px solid #ddd';
        item.style.display = 'flex';
        item.style.justifyContent = 'space-between';
        item.style.alignItems = 'center';

        const nameSpan = document.createElement('span');
        nameSpan.textContent = skill.name;
        nameSpan.style.cursor = 'pointer';
        nameSpan.onclick = () => loadSkill(skill);

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = '×';
        deleteBtn.style.background = 'none';
        deleteBtn.style.border = 'none';
        deleteBtn.style.color = '#ff4444';
        deleteBtn.style.cursor = 'pointer';
        deleteBtn.style.fontSize = '20px';
        deleteBtn.style.padding = '0 5px';
        deleteBtn.onclick = (e) =>
        {
          e.stopPropagation();
          uploadedSkills.splice(index, 1);
          updateSkillFilesList();
        };

        item.appendChild(nameSpan);
        item.appendChild(deleteBtn);
        list.appendChild(item);
      });
    }

    // 加载技能文件
    function loadSkill(skill)
    {
      try
      {
        // 将解析后的数据转换为字符串并发送到串口
        if (writer)
        {
          const skillString = JSON.stringify(skill.content);
          writer.write(new TextEncoder().encode(skillString + '\n'));
          addConsoleMessage([getText("skillLoaded").replace("{filename}", skill.name)]);
        } else
        {
          addConsoleMessage([getText("serialNotConnected")]);
        }
      } catch (err)
      {
        console.error(getText("loadSkillFailed"), err);
        addConsoleMessage([getText("skillLoadFailed")]);
      }
    }

    function loadWorkspace(file)
    {
      var reader = new FileReader();
      reader.onload = function (e)
      {
        try
        {
          var saveData = JSON.parse(e.target.result);

          // 加载工作区
          Blockly.serialization.workspaces.load(saveData, workspace);

          // 加载技能文件
          if (saveData.skills && Array.isArray(saveData.skills))
          {
            window.uploadedSkills = saveData.skills;
            updateSkillFilesList();
          }

          // 恢复startBlockIds
          if (saveData.startBlockIds && Array.isArray(saveData.startBlockIds))
          {
            startBlockIds = saveData.startBlockIds;
            // 验证保存的startBlockIds是否仍然存在于工作区中
            const existingBlocks = startBlockIds.filter(id => workspace.getBlockById(id));
            if (existingBlocks.length !== startBlockIds.length)
            {
              // 如果有些块不存在了，重新初始化
              startBlockIds = [];
              addDefaultConnectionBlock();
            }
          } else
          {
            // 如果没有保存的startBlockIds，重新初始化
            startBlockIds = [];
            addDefaultConnectionBlock();
          }

          // 保存当前文件信息
          currentFile = file;

          // 更新文件名和标签显示
          updateUIText();

          if (currentDeviceIP !== "192.168.4.1")
          {
            // 查找工作区中的make_connection积木块并更新IP地址
            const makeConnectionBlocks = workspace.getBlocksByType('make_connection');
            if (makeConnectionBlocks && makeConnectionBlocks.length > 0)
            {
              // 更新第一个make_connection积木块的IP_ADDRESS字段
              makeConnectionBlocks[0].setFieldValue(currentDeviceIP, 'IP_ADDRESS');
            }
          }

          // 不使用alert，而是在控制台显示加载成功信息
          const successMsg = getText('fileLoaded').replace('{filename}', file.name);
          addConsoleMessage([successMsg]);
        } catch (err)
        {
          console.error(getText("loadFileFailed"), err);
          alert(getText('loadFileFailed'));
        }
      };
      reader.readAsText(file);
    }

    document.addEventListener('keydown', function (event)
    {
      if ((event.ctrlKey || event.metaKey) && event.key === 's')
      {
        event.preventDefault();
        saveWorkspace();
      }
      if ((event.ctrlKey || event.metaKey) && event.key === 'o')
      {
        event.preventDefault();
        document.getElementById('loadInput').click();
      }
      // 添加撤销快捷键(Ctrl+Z)
      if ((event.ctrlKey || event.metaKey) && !event.shiftKey && event.key === 'z')
      {
        //prevent browser default behavior
        event.preventDefault();
      }
      // 添加重做快捷键(Ctrl+Y 或 Ctrl+Shift+Z)
      if ((event.ctrlKey || event.metaKey) &&
        ((!event.shiftKey && event.key.toLowerCase() === 'y') ||
          (event.shiftKey && event.key === 'z')))
      {
        event.preventDefault();
        // 使用redoStack_属性检查是否可以重做
        if (workspace.redoStack_ && workspace.redoStack_.length > 0)
        {
          workspace.undo(true);
          updateUndoRedoState();
        }
      }
    });

    function addConsoleMessage(args)
    {
      const logDiv = document.getElementById('consoleLog');
      const showTimestamp = document.getElementById('showTimestampBtn').classList.contains('active');
      const time = getFormattedTimestamp();

      const messageDiv = document.createElement('div');
      messageDiv.className = 'console-item';

      // 处理不同类型的参数
      const messages = Array.from(args).map(arg =>
      {
        if (typeof arg === 'object')
        {
          try
          {
            return JSON.stringify(arg, null, 2);
          } catch (e)
          {
            return String(arg);
          }
        }
        return String(arg);
      });

      const messageText = messages.join(' ');

      // 创建时间戳容器
      const timestampSpan = document.createElement('span');
      timestampSpan.className = 'timestamp';
      timestampSpan.textContent = `${time} `;
      timestampSpan.style.display = showTimestamp ? 'inline' : 'none';

      // 创建消息内容容器
      const messageSpan = document.createElement('span');
      messageSpan.className = 'message-content';
      messageSpan.textContent = `${messageText} `;

      // 将两个容器添加到消息div中
      messageDiv.appendChild(timestampSpan);
      messageDiv.appendChild(messageSpan);

      // 检测是否为"任务结束"消息，如果是则使用绿色字体
      if (messageText === getText('taskEnded'))
      {
        messageDiv.style.color = '#4CAF50'; // 使用绿色
        messageDiv.style.fontWeight = 'bold'; // 加粗显示
      }

      // 使用原生DOM方法确保立即渲染，改为添加到末尾
      logDiv.appendChild(messageDiv);

      // 保持最多显示500条记录
      while (logDiv.children.length > 500)
      {
        logDiv.removeChild(logDiv.firstChild);
      }

      // 立即滚动到底部，不使用setTimeout
      logDiv.scrollTop = logDiv.scrollHeight;

      // 强制DOM重绘，确保视图更新
      void logDiv.offsetHeight;
    }

    function clearConsole()
    {
      document.getElementById('consoleLog').innerHTML = '';
    }

    // 生成调试日志
    function generateLog()
    {
      try
      {
        // 获取当前时间戳
        const now = new Date();
        const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, -5);

        // 获取JavaScript代码
        let jsCode = '';
        try
        {
          jsCode = Blockly.JavaScript.workspaceToCode(workspace);
          if (!jsCode.trim())
          {
            jsCode = '// No blocks in workspace';
          }
        } catch (error)
        {
          jsCode = `// Error generating code: ${error.message}`;
        }

        // 获取Console Log内容
        const consoleLogElement = document.getElementById('consoleLog');
        let consoleLogContent = '';
        if (consoleLogElement)
        {
          // 提取文本内容，去除HTML标签
          const logEntries = consoleLogElement.querySelectorAll('.log-entry, .log-message');
          if (logEntries.length > 0)
          {
            const logTexts = Array.from(logEntries).map(entry =>
            {
              return entry.textContent || entry.innerText || '';
            });
            consoleLogContent = logTexts.join('\n');
          } else
          {
            // 如果没有找到特定的log条目，获取所有文本内容
            consoleLogContent = consoleLogElement.textContent || consoleLogElement.innerText || '';
          }

          if (!consoleLogContent.trim())
          {
            consoleLogContent = '// No console log output';
          }
        } else
        {
          consoleLogContent = '// Console log element not found';
        }

        // 获取Serial Log内容
        const serialLogElement = document.getElementById('serialOutput');
        let serialLogContent = '';
        if (serialLogElement)
        {
          // 提取文本内容，去除HTML标签
          const logEntries = serialLogElement.querySelectorAll('.log-entry, .log-message');
          if (logEntries.length > 0)
          {
            const logTexts = Array.from(logEntries).map(entry =>
            {
              return entry.textContent || entry.innerText || '';
            });
            serialLogContent = logTexts.join('\n');
          } else
          {
            // 如果没有找到特定的log条目，获取所有文本内容
            serialLogContent = serialLogElement.textContent || serialLogElement.innerText || '';
          }

          if (!serialLogContent.trim())
          {
            serialLogContent = '// No serial log output';
          }
        } else
        {
          serialLogContent = '// Serial log element not found';
        }

        // 生成Markdown格式的日志
        const logContent = `# Debug Log - ${now.toLocaleString()}

## Code
\`\`\`javascript
${jsCode}
\`\`\`

## Console Log
\`\`\`
${consoleLogContent}
\`\`\`

## Serial Log
\`\`\`
${serialLogContent}
\`\`\`

---
Generated at: ${now.toISOString()}
`;

        // 复制到剪贴板
        navigator.clipboard.writeText(logContent).then(() =>
        {
          console.log('Log copied to clipboard successfully');
        }).catch(err =>
        {
          console.error('Failed to copy to clipboard:', err);
          // 如果clipboard API失败，尝试使用旧的方法
          const textArea = document.createElement('textarea');
          textArea.value = logContent;
          document.body.appendChild(textArea);
          textArea.select();
          try
          {
            document.execCommand('copy');
            console.log('Log copied to clipboard using fallback method');
          } catch (fallbackErr)
          {
            console.error('Fallback copy method also failed:', fallbackErr);
          }
          document.body.removeChild(textArea);
        });

        // 下载为文件
        const filename = `log_${timestamp}.md`;
        const blob = new Blob([logContent], { type: 'text/markdown;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.style.display = 'none';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        console.log(`Debug log generated: ${filename}`);
        console.log('Log content also copied to clipboard for AI debugging');

      } catch (error)
      {
        console.error('Error generating log:', error);
        alert('Error generating log: ' + error.message);
      }
    }

    // 切换是否显示时间戳
    function toggleShowTimestamp()
    {
      const showTimestamp = !document.getElementById('showTimestampBtn').classList.contains('active');
      const btn = document.getElementById('showTimestampBtn');
      const consoleLog = document.getElementById('consoleLog');

      if (showTimestamp)
      {
        btn.classList.add('active');
      } else
      {
        btn.classList.remove('active');
      }

      // 获取所有时间戳容器并切换显示状态
      const timestampSpans = consoleLog.querySelectorAll('.timestamp');
      timestampSpans.forEach(span =>
      {
        span.style.display = showTimestamp ? 'inline' : 'none';
      });
    }

    // 切换是否显示串口时间戳
    function toggleShowSerialTimestamp()
    {
      const showSerialTimestamp = !document.getElementById('showSerialTimestampBtn').classList.contains('active');
      const btn = document.getElementById('showSerialTimestampBtn');
      const serialOutput = document.getElementById('serialOutput');

      if (showSerialTimestamp)
      {
        btn.classList.add('active');
      } else
      {
        btn.classList.remove('active');
      }

      // 获取所有时间戳容器并切换显示状态
      const timestampSpans = serialOutput.querySelectorAll('.timestamp');
      timestampSpans.forEach(span =>
      {
        span.style.display = showSerialTimestamp ? 'inline' : 'none';
      });
    }

    // 切换是否显示发送的命令
    function toggleShowSentCommands()
    {
      showSentCommands = !showSentCommands;
      // 更新按钮样式
      const btn = document.getElementById('showSentCommandsBtn');
      if (showSentCommands)
      {
        btn.classList.add('active');
      } else
      {
        btn.classList.remove('active');
      }
    }

    // 切换是否显示debug信息
    function toggleShowDebug()
    {
      showDebug = !showDebug;
      // 更新按钮样式
      const btn = document.getElementById('showDebugBtn');
      if (showDebug)
      {
        btn.classList.add('active');
      } else
      {
        btn.classList.remove('active');
      }
    }

    // 只重写 console.log
    const originalLog = console.log;
    console.log = function ()
    {
      // 检查是否为debug信息
      const message = Array.from(arguments).join(' ');
      const isDebugMessage = isDebugInfo(message);

      // 如果是debug信息且debug开关关闭，则不显示
      if (isDebugMessage && !showDebug)
      {
        originalLog.apply(console, arguments);
        return;
      }

      addConsoleMessage(arguments);
      originalLog.apply(console, arguments);
    };

    // 检查是否为debug信息的函数
    function isDebugInfo(message)
    {
      const debugPatterns = [
        /\[Heartbeat\]/,
        /handleMessage/,
        /message type/,
        /send message/,
        /Program ended/,
        /\[WebSocket\]/
      ];

      return debugPatterns.some(pattern => pattern.test(message));
    }

    // 添加串口通信相关的JavaScript代码
    let port = null;
    let reader = null;
    let writer = null;

    // 添加文件相关变量
    let currentFile = null;
    let currentFilePath = '';

    // 设备IP地址
    let currentDeviceIP = '192.168.4.1'; // 默认IP地址

    // 配置文件相关
    let config = {
      lastKnownIP: '192.168.4.1',
      lastConnectedTime: '',
      connectionHistory: [],
      autoConnect: true,
      connectionTimeout: 5000
    };

    // 添加命令历史记录相关变量
    let commandHistory = [];
    let historyIndex = -1;
    let tempInputValue = '';

    // 是否显示发送的命令
    let showSentCommands = false;

    // 是否显示debug信息
    let showDebug = false;

    let ipCheckTimer = null;
    let lastPartialIP = null;
    let serialBufferText = '';
    let serialBuffer = '';
    let lastSerialMessageTime = 0; // 记录上次收到串口消息的时间
    let serialOutputBuffer = ''; // 串口输出缓冲区
    let serialOutputTimer = null; // 串口输出处理定时器

    // ESP32开发板使用的USB串口芯片配置
    const ESP32_USB_CHIPS = [
      // 通用串口芯片厂商（只检查vendorId，不限制productId）
      { vendorId: 0x1a86, name: 'CH340/CH343' },  // 沁恒微电子（CH340、CH343等）
      { vendorId: 0x10c4, name: 'CP2102' },       // Silicon Labs（CP2102等）
      // ESP32内置USB（需要精确匹配）
      { vendorId: 0x303a, productId: 0x1001, name: 'ESP32-S2' }, // ESP32-S2 内置USB
      { vendorId: 0x303a, productId: 0x0002, name: 'ESP32-S3' }, // ESP32-S3 内置USB
    ];

    // 系统检测函数
    function detectOperatingSystem()
    {
      const userAgent = navigator.userAgent;
      const platform = navigator.platform;

      if (userAgent.includes('Chrome OS') || userAgent.includes('CrOS'))
      {
        return 'chromebook';
      } else if (platform.includes('Mac'))
      {
        return 'mac';
      } else if (platform.includes('Win'))
      {
        return 'windows';
      } else if (platform.includes('Linux'))
      {
        return 'linux';
      } else
      {
        return 'unknown';
      }
    }

    // 全局变量存储操作系统类型，页面加载时初始化一次
    const OPERATING_SYSTEM = detectOperatingSystem();

    // 检查串口是否为ESP32开发板使用的芯片
    function isESP32SerialPort(port)
    {
      try
      {
        const portInfo = port.getInfo();
        if (!portInfo.usbVendorId || !portInfo.usbProductId)
        {
          return false;
        }

        return ESP32_USB_CHIPS.some(chip =>
        {
          // 对于有productId的条目（ESP32-S2/S3），需要精确匹配
          if (chip.productId !== undefined)
          {
            return chip.vendorId === portInfo.usbVendorId &&
              chip.productId === portInfo.usbProductId;
          }
          // 对于通用芯片（CH340/CP2102），只检查vendorId
          return chip.vendorId === portInfo.usbVendorId;
        });
      } catch (error)
      {
        console.warn(getText("cannotGetPortInfo"), error);
        return false;
      }
    }

    // 获取串口显示名称（Arduino IDE风格）
    function getSerialPortDisplayName(port)
    {
      try
      {
        const portInfo = port.getInfo();
        const os = OPERATING_SYSTEM;

        if (os === 'mac')
        {
          // macOS: 生成类似 cu.wchusbserial58CF0756201 的格式
          const vendorId = portInfo.usbVendorId?.toString(16).toUpperCase() || '0000';
          const productId = portInfo.usbProductId?.toString(16).toUpperCase() || '0000';

          // 根据不同的芯片生成不同的前缀
          if (portInfo.usbVendorId === 0x1a86)
          {
            // CH340/CH343
            return `cu.wchusbserial${vendorId}${productId}`;
          } else if (portInfo.usbVendorId === 0x10c4)
          {
            // CP2102
            return `cu.SLAB_USBtoUART`;
          } else
          {
            // 其他USB串口
            return `cu.usbserial${vendorId}${productId}`;
          }
        } else if (os === 'linux')
        {
          // Linux: 类似格式
          const vendorId = portInfo.usbVendorId?.toString(16).toUpperCase() || '0000';
          const productId = portInfo.usbProductId?.toString(16).toUpperCase() || '0000';
          return `ttyUSB${vendorId}${productId}`;
        } else if (os === 'windows')
        {
          // Windows: 显示芯片名称
          const chip = ESP32_USB_CHIPS.find(chip =>
          {
            if (chip.productId !== undefined)
            {
              return chip.vendorId === portInfo.usbVendorId &&
                chip.productId === portInfo.usbProductId;
            }
            return chip.vendorId === portInfo.usbVendorId;
          });
          return chip ? chip.name : 'USB Serial';
        } else
        {
          // 其他系统
          const vendorId = portInfo.usbVendorId?.toString(16).toUpperCase() || '0000';
          const productId = portInfo.usbProductId?.toString(16).toUpperCase() || '0000';
          return `Serial${vendorId}${productId}`;
        }
      } catch (error)
      {
        console.warn(getText("cannotGetPortDisplayName"), error);
        return 'Serial Port';
      }
    }

    // 生成简短的4位伪序列号（基于端口在列表中的位置）
    function generatePortPseudoSerial(port, allPorts, sameTypePorts)
    {
      try
      {
        // 获取当前端口在相同类型设备中的索引
        const indexInSameType = sameTypePorts.indexOf(port);
        const deviceNumber = indexInSameType >= 0 ? indexInSameType + 1 : 1;

        // 获取当前端口在所有端口中的索引
        const indexInAll = allPorts.indexOf(port);
        const globalIndex = indexInAll >= 0 ? indexInAll : 0;

        // 生成简短的4位数字标识
        // 基数从1000开始，确保是4位数
        const baseId = 1000 + (deviceNumber * 10) + (globalIndex % 10);

        return baseId.toString();
      } catch (error)
      {
        // 如果生成失败，使用随机4位数
        const randomId = 1000 + Math.floor(Math.random() * 9000);
        return randomId.toString();
      }
    }

    // 获取串口智能显示名称（多设备时只显示有区分度的部分）
    function getSmartPortDisplayName(port, allPorts)
    {
      try
      {
        // 如果只有一个设备，直接显示完整名称
        if (!allPorts || allPorts.length <= 1)
        {
          return getSerialPortDisplayName(port);
        }

        // 获取所有设备的完整名称
        const allNames = allPorts.map(p => getSerialPortDisplayName(p));
        const currentName = getSerialPortDisplayName(port);

        // 如果名称都不同，直接返回
        const duplicateNames = allNames.filter(name => name === currentName);
        if (duplicateNames.length <= 1)
        {
          return currentName;
        }

        // 对于有相同前缀的设备，生成类似真实设备名称的显示
        const portInfo = port.getInfo();
        const os = OPERATING_SYSTEM;

        // 获取芯片信息
        const sameTypeChip = ESP32_USB_CHIPS.find(chip =>
        {
          if (chip.productId !== undefined)
          {
            return chip.vendorId === portInfo.usbVendorId &&
              chip.productId === portInfo.usbProductId;
          }
          return chip.vendorId === portInfo.usbVendorId;
        });

        const chipName = sameTypeChip ? sameTypeChip.name : 'USB';

        // 获取相同类型的端口列表
        const sameTypePorts = allPorts.filter(p =>
        {
          try
          {
            const pInfo = p.getInfo();
            return pInfo.usbVendorId === portInfo.usbVendorId &&
              pInfo.usbProductId === portInfo.usbProductId;
          } catch (e)
          {
            return false;
          }
        });

        // 生成伪序列号来区分设备
        const pseudoSerial = generatePortPseudoSerial(port, allPorts, sameTypePorts);

        // 调试信息（仅在调试模式下显示）
        if (typeof showDebug !== 'undefined' && showDebug)
        {
          console.log(getText("generatedPseudoSerial").replace("{chipName}", chipName).replace("{serial}", pseudoSerial).replace("{index}", sameTypePorts.indexOf(port) + 1).replace("{total}", sameTypePorts.length));
        }

        if (os === 'mac')
        {
          // macOS: 使用简洁的4位数字
          return `cu.wchusbserial${pseudoSerial}`;
        } else if (os === 'linux')
        {
          return `ttyUSB-${pseudoSerial}`;
        } else if (os === 'windows')
        {
          return `${chipName}(${pseudoSerial})`;
        } else
        {
          return `${chipName}-${pseudoSerial}`;
        }
      } catch (error)
      {
        console.warn(getText("cannotGetPortDisplayName"), error);
        return 'Serial Port';
      }
    }

    // 检查串口是否为有效的usbserial端口（Mac系统下排除后缀全为0的端口）
    function isValidUsbserialPort(port)
    {
      try
      {
        const portInfo = port.getInfo();
        const os = OPERATING_SYSTEM;

        if (os === 'mac')
        {
          // 在Mac系统下，检查是否为usbserial端口且后缀不全为0
          const vendorId = portInfo.usbVendorId?.toString(16).toUpperCase() || '0000';
          const productId = portInfo.usbProductId?.toString(16).toUpperCase() || '0000';

          // 检查vendorId和productId是否全为0
          if (vendorId === '0000' && productId === '0000')
          {
            return false;
          }

          // 检查是否为usbserial相关端口
          if (portInfo.usbVendorId === 0x1a86 || portInfo.usbVendorId === 0x10c4)
          {
            return true;
          }

          // 对于其他USB串口，检查是否包含有效的vendorId和productId
          return vendorId !== '0000' && productId !== '0000';
        }

        // 其他系统保持原有逻辑
        return true;
      } catch (error)
      {
        console.warn("Cannot get port info for validation:", error);
        return false;
      }
    }

    // 获取ESP32串口显示名称（保留用于ESP32特定功能）
    function getESP32PortDisplayName(port)
    {
      try
      {
        const portInfo = port.getInfo();
        const chip = ESP32_USB_CHIPS.find(chip =>
        {
          if (chip.productId !== undefined)
          {
            return chip.vendorId === portInfo.usbVendorId &&
              chip.productId === portInfo.usbProductId;
          }
          return chip.vendorId === portInfo.usbVendorId;
        });

        const os = OPERATING_SYSTEM;
        let displayName = '';

        if (chip)
        {
          // 如果是ESP32芯片
          if (os === 'windows')
          {
            displayName = `${chip.name} ESP32`;
          } else if (os === 'mac' || os === 'linux')
          {
            displayName = `${chip.name} (ESP32)`;
          } else
          {
            displayName = `${chip.name} ESP32`;
          }
        } else
        {
          // 如果不是ESP32芯片，显示USB信息
          const vendorId = portInfo.usbVendorId?.toString(16) || 'unknown';
          const productId = portInfo.usbProductId?.toString(16) || 'unknown';
          displayName = `USB Serial (0x${vendorId}:0x${productId})`;
        }

        return displayName;
      } catch (error)
      {
        console.warn(getText("cannotGetPortDisplayName"), error);
        return 'Unknown Serial Port';
      }
    }

    // 获取并过滤ESP32串口
    async function getESP32SerialPorts()
    {
      try
      {
        // 获取所有已授权的串口
        const ports = await navigator.serial.getPorts();

        // 过滤有效的串口（在Mac系统下排除后缀全为0的端口）
        const validPorts = ports.filter(port => isValidUsbserialPort(port));

        // 过滤出ESP32串口
        const esp32Ports = validPorts.filter(port => isESP32SerialPort(port));

        console.log(getText("foundESP32Ports").replace("{count}", esp32Ports.length));
        return esp32Ports;
      } catch (error)
      {
        console.error(getText("getPortListFailed"), error);
        return [];
      }
    }

    // 创建ESP32串口选择对话框
    function createESP32PortSelector(ports)
    {
      return new Promise((resolve, reject) =>
      {
        if (typeof showDebug !== 'undefined' && showDebug)
        {
          console.log(getText("creatingESP32PortSelector"));
        }

        // 创建遮罩层
        const overlay = document.createElement('div');
        overlay.className = 'esp32-port-selector';

        // 添加调试样式
        overlay.style.position = 'fixed';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.background = 'rgba(0, 0, 0, 0.5)';
        overlay.style.zIndex = '1000';
        overlay.style.display = 'flex';
        overlay.style.alignItems = 'center';
        overlay.style.justifyContent = 'center';

        // 创建对话框
        const dialog = document.createElement('div');
        dialog.className = 'esp32-port-dialog';

        // 添加调试样式
        dialog.style.background = 'white';
        dialog.style.padding = '20px';
        dialog.style.borderRadius = '8px';
        dialog.style.minWidth = '300px';
        dialog.style.maxWidth = '500px';
        dialog.style.boxShadow = '0 4px 20px rgba(0, 0, 0, 0.3)';
        dialog.style.margin = '20px';

        dialog.innerHTML = `
          <h3 style="margin: 0 0 15px 0; color: #333;">${getText("selectESP32Port")}</h3>
          <div style="margin-bottom: 15px;">
            ${ports.map((port, index) =>
        {
          const displayName = getSmartPortDisplayName(port, ports);
          return `
                <div class="esp32-port-option" onclick="selectESP32Port(${index})">
                  <strong>${displayName}</strong>
                </div>
              `;
        }).join('')}
          </div>
          <div class="esp32-port-buttons">
            <button class="cancel" onclick="cancelESP32PortSelection()">${getText("cancel")}</button>
          </div>
        `;

        // 添加选择函数到全局作用域
        window.selectESP32Port = (index) =>
        {
          const selectedPort = ports[index];
          document.body.removeChild(overlay);
          delete window.selectESP32Port;
          delete window.cancelESP32PortSelection;
          resolve(selectedPort);
        };

        window.cancelESP32PortSelection = () =>
        {
          document.body.removeChild(overlay);
          delete window.selectESP32Port;
          delete window.cancelESP32PortSelection;
          reject(new Error(getText("userCancelledSelection")));
        };

        // 将对话框添加到遮罩层中
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);

        if (typeof showDebug !== 'undefined' && showDebug)
        {
          console.log(getText("esp32PortSelectorCreated"));
        }
      });
    }

    // 创建所有串口选择对话框
    function createAllPortsSelector(ports)
    {
      return new Promise((resolve, reject) =>
      {
        console.log("Creating all ports selector dialog...");

        // 创建遮罩层
        const overlay = document.createElement('div');
        overlay.className = 'esp32-port-selector';

        // 添加调试样式
        overlay.style.position = 'fixed';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.background = 'rgba(0, 0, 0, 0.5)';
        overlay.style.zIndex = '1000';
        overlay.style.display = 'flex';
        overlay.style.alignItems = 'center';
        overlay.style.justifyContent = 'center';

        // 创建对话框
        const dialog = document.createElement('div');
        dialog.className = 'esp32-port-dialog';

        // 添加调试样式
        dialog.style.background = 'white';
        dialog.style.padding = '20px';
        dialog.style.borderRadius = '8px';
        dialog.style.minWidth = '300px';
        dialog.style.maxWidth = '500px';
        dialog.style.boxShadow = '0 4px 20px rgba(0, 0, 0, 0.3)';
        dialog.style.margin = '20px';

        dialog.innerHTML = `
          <h3 style="margin: 0 0 15px 0; color: #333;">${getText("selectSerialPort")}</h3>
          <div style="margin-bottom: 15px;">
            ${ports.map((port, index) =>
        {
          const displayName = getSmartPortDisplayName(port, ports);
          return `
                <div class="esp32-port-option" onclick="selectAllPort(${index})">
                  <strong>${displayName}</strong>
                </div>
              `;
        }).join('')}
            <div class="esp32-port-option esp32-port-system-option" onclick="selectSystemPort()">
              <strong>🔍 ${getText("selectOtherPort")}</strong>
              <small style="display: block; color: #666; margin-top: 2px;">${getText("selectOtherPortDesc")}</small>
            </div>
          </div>
          <div class="esp32-port-buttons">
            <button class="cancel" onclick="cancelAllPortSelection()">${getText("cancel")}</button>
          </div>
        `;

        // 添加选择函数到全局作用域
        window.selectAllPort = (index) =>
        {
          const selectedPort = ports[index];
          document.body.removeChild(overlay);
          delete window.selectAllPort;
          delete window.selectSystemPort;
          delete window.cancelAllPortSelection;
          resolve(selectedPort);
        };

        window.selectSystemPort = async () =>
        {
          try
          {
            const systemPort = await navigator.serial.requestPort();
            document.body.removeChild(overlay);
            delete window.selectAllPort;
            delete window.selectSystemPort;
            delete window.cancelAllPortSelection;
            resolve(systemPort);
          } catch (error)
          {
            if (error.name === 'NotFoundError')
            {
              // 用户取消选择，不关闭对话框，让用户可以继续选择其他选项
              console.log('User cancelled system port selection');
            } else
            {
              console.error('Error in system port selection:', error);
              document.body.removeChild(overlay);
              delete window.selectAllPort;
              delete window.selectSystemPort;
              delete window.cancelAllPortSelection;
              reject(error);
            }
          }
        };

        window.cancelAllPortSelection = () =>
        {
          document.body.removeChild(overlay);
          delete window.selectAllPort;
          delete window.selectSystemPort;
          delete window.cancelAllPortSelection;
          reject(new Error(getText("userCancelledSelection")));
        };

        // 将对话框添加到遮罩层中
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);

        console.log("All ports selector dialog created and added to DOM");
      });
    }

    async function openSerialPort()
    {
      try
      {

        // 检测操作系统
        const os = OPERATING_SYSTEM;
        if (typeof showDebug !== 'undefined' && showDebug)
        {
          console.log(getText("detectedOS").replace("{os}", os));
        }

        // 获取所有已授权的串口
        const allPorts = await navigator.serial.getPorts();
        if (typeof showDebug !== 'undefined' && showDebug)
        {
          console.log(getText("foundAuthorizedPorts").replace("{count}", allPorts.length));
        }

        // 过滤有效的串口（在Mac系统下排除后缀全为0的端口）
        const validPorts = allPorts.filter(port => isValidUsbserialPort(port));
        if (typeof showDebug !== 'undefined' && showDebug)
        {
          console.log(getText("validPortsAfterFiltering").replace("{valid}", validPorts.length).replace("{filtered}", allPorts.length - validPorts.length));

          // 在Mac系统下显示过滤详情
          if (os === 'mac' && allPorts.length !== validPorts.length)
          {
            console.log("On macOS, filtered out ports with vendorId=0x0000 and productId=0x0000");
          }
        }

        // 显示有效串口的简要信息
        if (typeof showDebug !== 'undefined' && showDebug)
        {
          validPorts.forEach((port, index) =>
          {
            try
            {
              const displayName = getSmartPortDisplayName(port, validPorts);
              const portInfo = port.getInfo();
              const isESP32 = isESP32SerialPort(port);
              console.log(getText("portInfo").replace("{index}", index + 1).replace("{name}", displayName));

              // 显示硬件信息（用于诊断端口识别问题）
              console.log(getText("hardwareInfo").replace("{vid}", portInfo.usbVendorId?.toString(16)).replace("{pid}", portInfo.usbProductId?.toString(16)).replace("{isESP32}", isESP32));
            } catch (error)
            {
              console.log(getText("portInfoError").replace("{index}", index + 1));
            }
          });
        }

        // 获取ESP32串口列表
        const esp32Ports = validPorts.filter(port => isESP32SerialPort(port));

        // 显示ESP32端口检测结果
        if (typeof showDebug !== 'undefined' && showDebug)
        {
          console.log(getText("esp32DetectionResult").replace("{esp32Count}", esp32Ports.length).replace("{totalCount}", validPorts.length));
        }

        // 总是显示完整的串口选择，包括系统选择选项
        if (validPorts.length === 0)
        {
          // 如果没有任何已授权的串口，直接请求用户选择新的串口
          if (typeof showDebug !== 'undefined' && showDebug)
          {
            console.log(getText("noAuthorizedPorts"));
          }
          const selectPort = await navigator.serial.requestPort();
          port = selectPort;
        } else
        {
          // 显示包含所有端口选择的对话框（包括"选择其他端口"选项）
          if (typeof showDebug !== 'undefined' && showDebug)
          {
            console.log(getText("showingPortsForSelection").replace("{count}", validPorts.length));
          }
          port = await createAllPortsSelector(validPorts);
        }

        // 连接串口
        try
        {
          await port.open({ baudRate: 115200 });
          console.log(getText("esp32PortConnected"));
        } catch (portError)
        {
          // 检查是否是因为串口被占用
          if (portError.name === 'NetworkError' ||
            portError.message.includes('failed to open') ||
            portError.message.includes('busy') ||
            portError.message.includes('in use'))
          {
            // 显示提示窗口
            alert(getText("serialPortBusy"));
            throw new Error('Serial port busy');
          } else
          {
            // 其他错误，继续抛出
            throw portError;
          }
        }

        // 设置读取器和写入器（用于验证）
        reader = port.readable.getReader();
        writer = port.writable.getWriter();

        // 验证串口连接 - 发送'?'字符并等待回复
        console.log(getText("validatingSerialConnection"));
        const validationResult = await validateSerialConnection();

        if (!validationResult)
        {
          // 验证失败，立即显示错误窗口，然后快速关闭串口
          console.log(getText("serialValidationFailed"));
          showCustomAlert(getText("serialValidationFailed"), getText("connectionFailed"));
          // 快速关闭串口，不等待超时
          quickCloseSerialPort();
          return;
        }

        console.log(getText("serialValidationSuccess"));

        // 验证成功后显示串口界面
        const serialInterface = document.getElementById('serialInterface');
        serialInterface.style.display = 'flex';

        // 添加connected类，调整串口容器样式
        const serialContainer = document.getElementById('serialContainer');
        serialContainer.classList.add('connected');

        // 显示分隔线
        document.getElementById('console-serial-divider').style.display = 'block';

        // 设置控制台和串口区域的初始高度比例为50%/50%
        document.getElementById('consoleWindow').style.flex = '50';
        serialContainer.style.flex = '49'; // 减去分隔线高度

        // 更新按钮状态
        document.getElementById('openSerialBtn').style.display = 'none'; // 隐藏连接按钮
        document.getElementById('showSerialTimestampBtn').style.display = 'inline-flex'; // 显示时间戳按钮
        document.getElementById('closeSerialBtn').style.display = 'inline-flex'; // 显示关闭按钮
        document.getElementById('clearSerialBtn').style.display = 'inline-flex'; // 显示清除按钮

        // 更新串口标题显示连接的设备信息
        const serialTitle = document.getElementById('serialOutputTitle');
        if (serialTitle)
        {
          const displayName = getSerialPortDisplayName(port);
          serialTitle.textContent = getText("serialMonitorTitle").replace("{portName}", displayName);
        }

        // 强制重新调整工作区大小，确保布局不变
        // 等DOM更新后再执行调整
        setTimeout(function ()
        {
          // 确保工作区和串口区域的宽度比例保持不变
          const container = document.querySelector('.workspace-container');
          const blocklyDiv = document.getElementById('blocklyDiv');
          const windowsContainer = document.querySelector('.windows-container');

          // 重新应用之前的宽度比例
          if (blocklyDiv.style.width)
          {
            const blocklyWidth = blocklyDiv.style.width;
            blocklyDiv.style.flexBasis = blocklyWidth;
            blocklyDiv.style.width = blocklyWidth;

            // 确保窗口容器宽度正确
            const blocklyPercent = parseFloat(blocklyWidth);
            windowsContainer.style.flexBasis = `${99 - blocklyPercent}% `;
            windowsContainer.style.width = `${99 - blocklyPercent}% `;
          }

          resizeBlocklyWorkspace();
          repositionUndoRedoButtons();
        }, 100);

        // 开始读取串口数据
        readSerialData();

        // 连接成功后自动发送'w'指令获取IP地址
        await sendWifiCommand();

      } catch (error)
      {
        console.error(getText("serialConnectionError"), error);
        // 连接失败时重置所有串口相关变量
        port = null;
        writer = null;
        reader = null;
        // 只有在没有WebSocket连接时才重置Quick Connect按钮
        // 如果有currentDeviceIP，说明可能还有WebSocket连接，不重置按钮
        if (!currentDeviceIP || currentDeviceIP === '192.168.4.1')
        {
          resetQuickConnectButton();
          if (typeof showDebug !== 'undefined' && showDebug)
          {
            console.log('Reset Quick Connect button (no WebSocket connection)');
          }
        } else
        {
          // 如果有IP地址，保持按钮显示IP
          updateQuickConnectButtonState(currentDeviceIP);
          if (typeof showDebug !== 'undefined' && showDebug)
          {
            console.log(`Kept Quick Connect button showing IP: ${currentDeviceIP}`);
          }
        }
        // 抛出异常，让调用者知道连接失败
        throw error;
      }
    }

    // 快速关闭串口（用于验证失败时，不等待超时）
    function quickCloseSerialPort()
    {
      try
      {
        if (reader)
        {
          reader.cancel().catch(() => { }); // 忽略错误
          reader = null;
        }

        if (writer)
        {
          writer.close().catch(() => { }); // 忽略错误
          writer = null;
        }

        if (port)
        {
          port.close().catch(() => { }); // 忽略错误
          port = null;
        }

        // 快速重置UI状态
        const serialInterface = document.getElementById('serialInterface');
        if (serialInterface) serialInterface.style.display = 'none';

        const serialContainer = document.getElementById('serialContainer');
        if (serialContainer) serialContainer.classList.remove('connected');

        const openSerialBtn = document.getElementById('openSerialBtn');
        if (openSerialBtn) openSerialBtn.style.display = 'inline-flex';

        const showSerialTimestampBtn = document.getElementById('showSerialTimestampBtn');
        if (showSerialTimestampBtn) showSerialTimestampBtn.style.display = 'none';

        const closeSerialBtn = document.getElementById('closeSerialBtn');
        if (closeSerialBtn) closeSerialBtn.style.display = 'none';

        const clearSerialBtn = document.getElementById('clearSerialBtn');
        if (clearSerialBtn) clearSerialBtn.style.display = 'none';

        // 重置串口监视器标题
        const serialTitle = document.getElementById('serialOutputTitle');
        if (serialTitle)
        {
          serialTitle.textContent = getText("serialOutput");
        }

        console.log('Quick serial port close completed');
      } catch (error)
      {
        console.warn('Quick close error:', error);
      }
    }

    async function closeSerialPort()
    {
      try
      {
        // 添加超时处理，防止硬件断开时卡住
        const timeout = TIMEOUT_CONFIG.SERIAL.PORT_CLOSE_TIMEOUT; // 使用配置的端口关闭超时

        if (reader)
        {
          try
          {
            // 使用Promise.race添加超时
            await Promise.race([
              reader.cancel(),
              new Promise((_, reject) => setTimeout(() => reject(new Error('Reader cancel timeout')), TIMEOUT_CONFIG.SERIAL.READER_CANCEL_TIMEOUT))
            ]);
            console.log('Reader cancelled successfully');
          } catch (readerError)
          {
            console.warn('Failed to cancel reader:', readerError);
          } finally
          {
            reader = null;
          }
        }

        if (writer)
        {
          try
          {
            // 使用Promise.race添加超时
            await Promise.race([
              writer.close(),
              new Promise((_, reject) => setTimeout(() => reject(new Error('Writer close timeout')), TIMEOUT_CONFIG.SERIAL.WRITER_CLOSE_TIMEOUT))
            ]);
            console.log('Writer closed successfully');
          } catch (writerError)
          {
            console.warn('Failed to close writer:', writerError);
          } finally
          {
            writer = null;
          }
        }

        if (port)
        {
          try
          {
            // 使用Promise.race添加超时
            await Promise.race([
              port.close(),
              new Promise((_, reject) => setTimeout(() => reject(new Error('Port close timeout')), TIMEOUT_CONFIG.SERIAL.PORT_CLOSE_TIMEOUT))
            ]);
            console.log('Port closed successfully');
          } catch (portError)
          {
            console.warn('Failed to close port:', portError);
          } finally
          {
            port = null;
          }
        }

        // 更新UI状态
        document.getElementById('serialInterface').style.display = 'none';

        // 移除connected类，恢复串口容器默认样式
        const serialContainer = document.getElementById('serialContainer');
        serialContainer.classList.remove('connected');

        // 调整控制台和串口区域的比例，控制台占据大部分空间
        document.getElementById('consoleWindow').style.flex = '90';
        serialContainer.style.flex = '10';

        // 隐藏分隔线
        document.getElementById('console-serial-divider').style.display = 'none';
        document.getElementById('openSerialBtn').style.display = 'inline-flex'; // 显示连接按钮
        document.getElementById('showSerialTimestampBtn').style.display = 'none'; // 隐藏时间戳按钮
        document.getElementById('closeSerialBtn').style.display = 'none'; // 隐藏关闭按钮
        document.getElementById('clearSerialBtn').style.display = 'none'; // 隐藏清除按钮

        // 重置串口监视器标题
        const serialTitle = document.getElementById('serialOutputTitle');
        if (serialTitle)
        {
          serialTitle.textContent = getText("serialOutput");
        }

        // 只有在没有WebSocket连接时才重置Quick Connect按钮
        // 如果有currentDeviceIP，说明可能还有WebSocket连接，不重置按钮
        if (!currentDeviceIP || currentDeviceIP === '192.168.4.1')
        {
          resetQuickConnectButton();
        } else
        {
          // 如果有IP地址，保持按钮显示IP
          updateQuickConnectButtonState(currentDeviceIP);
        }

        // 强制重新调整工作区大小
        setTimeout(function ()
        {
          resizeBlocklyWorkspace();
          repositionUndoRedoButtons();
        }, 100);

        // 不要重置当前IP地址，保留上一次的连接信息
        // currentDeviceIP = '192.168.4.1'; // 重置为默认IP
      } catch (error)
      {
        console.error(getText("closeSerialError"), error);
      }
    }

    async function quickConnect()
    {
      // 检查串口是否已连接
      if (!port)
      {
        try
        {
          // 如果串口未连接，先尝试连接串口
          await openSerialPort();
        } catch (error)
        {
          if (typeof showDebug !== 'undefined' && showDebug)
          {
            console.log('Serial port connection failed, trying configured IP...');
          }

          // 串口连接失败，尝试使用配置文件中的IP地址
          const connectedWithConfig = await tryConnectWithConfigIP();

          if (!connectedWithConfig)
          {
            // 如果配置的IP地址也连接失败，显示WiFi配置对话框
            console.log('Both serial and configured IP failed, showing WiFi config dialog');
            showWifiConfigDialog();
            return; // 显示WiFi配置界面后退出
          }
        }
      }

      // 如果串口已连接，尝试发送WiFi命令获取IP地址
      if (writer)
      {
        await sendWifiCommand();
      }
    }

    function closeWifiDialog()
    {
      const dialog = document.querySelector('.wifi-dialog');
      const overlay = document.querySelector('.overlay');
      if (dialog) dialog.remove();
      if (overlay) overlay.remove();
    }

    // 发送WiFi命令获取IP地址
    async function sendWifiCommand()
    {
      if (!writer)
      {
        console.log(getText('noSerialWriterAvailable'));
        showWifiConfigDialog();
        return;
      }

      try
      {
        // 发送'w'指令获取IP地址
        const command = 'w\n';
        await writer.write(new TextEncoder().encode(command));
        console.log(getText('wifiCommandSent'));

        // 等待一段时间让设备响应
        setTimeout(() =>
        {
          // 检查是否获取到了IP地址
          if (!currentDeviceIP || currentDeviceIP === '192.168.4.1')
          {
            // 如果没有获取到IP地址或获取到的是默认AP模式IP，显示WiFi配置界面
            console.log(getText('noValidIPReceived'));
            showWifiConfigDialog();
          }
        }, 3000); // 等待3秒

      } catch (error)
      {
        console.error('Failed to send WiFi command:', error);
        // 发送失败时显示WiFi配置界面
        showWifiConfigDialog();
      }
    }

    // 显示WiFi配置对话框
    function showWifiConfigDialog()
    {
      // 检查是否已经存在对话框，避免重复创建
      if (document.querySelector('.wifi-dialog'))
      {
        return;
      }

      // 创建遮罩层
      const overlay = document.createElement('div');
      overlay.className = 'overlay';
      document.body.appendChild(overlay);

      // 创建对话框
      const dialog = document.createElement('div');
      dialog.className = 'wifi-dialog';
      dialog.innerHTML = `
        <h3>${getText("wifiConfig")}</h3>
        <p style="color: #666; margin-bottom: 15px; font-size: 14px;">
          ${getText("wifiConfigDescription") || "Please enter your WiFi credentials to connect the robot to your network."}
        </p>
        <input type="text" id="ssidInput" placeholder="${getText("ssidPlaceholder")}" autocomplete="off">
        <input type="password" id="passwordInput" placeholder="${getText("passwordPlaceholder")}" autocomplete="off">
        <div class="button-container">
          <button class="cancel" onclick="closeWifiDialog()">${getText("cancel")}</button>
          <button class="confirm" onclick="confirmWifiSettings()">${getText("confirm")}</button>
        </div>
      `;
      document.body.appendChild(dialog);

      // 自动聚焦到SSID输入框
      setTimeout(() =>
      {
        const ssidInput = document.getElementById('ssidInput');
        if (ssidInput)
        {
          ssidInput.focus();
        }
      }, 100);

      // 添加回车键支持
      const ssidInput = document.getElementById('ssidInput');
      const passwordInput = document.getElementById('passwordInput');

      if (ssidInput)
      {
        ssidInput.addEventListener('keypress', function (e)
        {
          if (e.key === 'Enter')
          {
            passwordInput.focus();
          }
        });
      }

      if (passwordInput)
      {
        passwordInput.addEventListener('keypress', function (e)
        {
          if (e.key === 'Enter')
          {
            confirmWifiSettings();
          }
        });
      }
    }

    // 重置Quick Connect按钮样式和文本为默认状态
    function resetQuickConnectButton()
    {
      const quickConnectBtn = document.getElementById('quickConnectBtn');
      if (quickConnectBtn)
      {
        quickConnectBtn.textContent = getText("quickConnect");
        quickConnectBtn.style.backgroundColor = ''; // 恢复默认颜色
        quickConnectBtn.removeAttribute('data-connected'); // 移除连接状态标记
      }
    }

    // 更新快速连接按钮状态（统一管理函数）
    function updateQuickConnectButtonState(ip = null)
    {
      const quickConnectBtn = document.getElementById('quickConnectBtn');
      if (!quickConnectBtn) return;

      if (ip)
      {
        // 显示IP地址（已连接状态）
        quickConnectBtn.textContent = ip;
        quickConnectBtn.style.backgroundColor = '#4CAF50';
        quickConnectBtn.setAttribute('data-connected', 'true');
      } else
      {
        // 显示默认文本（未连接状态）
        quickConnectBtn.textContent = getText("quickConnect");
        quickConnectBtn.style.backgroundColor = '';
        quickConnectBtn.removeAttribute('data-connected');
      }
    }

    // 语言切换时处理快速连接按钮状态
    function handleQuickConnectButtonOnLanguageChange()
    {
      const quickConnectBtn = document.getElementById('quickConnectBtn');
      if (!quickConnectBtn) return;

      if (quickConnectBtn.hasAttribute('data-connected'))
      {
        // 如果按钮标记为已连接，检查是否有有效的IP地址
        if (currentDeviceIP && currentDeviceIP !== '192.168.4.1')
        {
          // 有有效的IP地址，保持显示IP地址
          quickConnectBtn.textContent = currentDeviceIP;
        } else
        {
          // 没有有效的IP地址，重置为未连接状态
          quickConnectBtn.textContent = getText("quickConnect");
          quickConnectBtn.removeAttribute('data-connected');
          quickConnectBtn.style.backgroundColor = '';
        }
      } else
      {
        // 如果按钮未连接，更新为当前语言的文本
        quickConnectBtn.textContent = getText("quickConnect");
      }
    }

    // 将函数暴露到全局作用域，供translations.js调用
    window.handleQuickConnectButtonOnLanguageChange = handleQuickConnectButtonOnLanguageChange;

    // 显示通知消息
    function showNotification(message, type = 'info')
    {
      // 创建通知元素
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 12px 20px;
        border-radius: 4px;
        color: white;
        font-size: 14px;
        z-index: 10000;
        max-width: 300px;
        word-wrap: break-word;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        transition: all 0.3s ease;
      `;

      // 根据类型设置颜色
      switch (type)
      {
        case 'success':
          notification.style.backgroundColor = '#4CAF50';
          break;
        case 'error':
          notification.style.backgroundColor = '#f44336';
          break;
        case 'warning':
          notification.style.backgroundColor = '#ff9800';
          break;
        default:
          notification.style.backgroundColor = '#2196F3';
      }

      notification.textContent = message;
      document.body.appendChild(notification);

      // 3秒后自动移除
      setTimeout(() =>
      {
        if (notification.parentNode)
        {
          notification.style.opacity = '0';
          notification.style.transform = 'translateX(100%)';
          setTimeout(() =>
          {
            if (notification.parentNode)
            {
              notification.parentNode.removeChild(notification);
            }
          }, 300);
        }
      }, 3000);
    }

    async function confirmWifiSettings()
    {
      const ssid = document.getElementById('ssidInput').value.trim();
      const password = document.getElementById('passwordInput').value.trim();

      if (!ssid)
      {
        alert(getText("enterWifiName") || "Please enter WiFi name");
        return;
      }

      // 显示加载状态
      const confirmBtn = document.querySelector('.wifi-dialog .confirm');
      const originalText = confirmBtn.textContent;
      confirmBtn.textContent = getText("connecting") || "Connecting...";
      confirmBtn.disabled = true;

      const command = `w%${ssid}%${password}\n`;

      try
      {
        if (writer)
        {
          await writer.write(new TextEncoder().encode(command));
          console.log(getText('wifiConfigCommandSent'));
        }
        else
        {
          console.log(getText('noSerialWriterButSettingsSaved'));
        }

        closeWifiDialog();

        // 显示成功消息
        showNotification(getText("wifiConfigSent") || "WiFi configuration sent successfully. The robot will reboot and connect to your network.", 'success');

        // 等待一段时间后尝试连接
        setTimeout(async () =>
        {
          console.log(getText('attemptingConnectAfterWifiConfig'));
          // 尝试使用新的WiFi配置连接
          await tryConnectWithConfigIP();
        }, 5000); // 等待5秒让设备重启并连接

      } catch (error)
      {
        console.error(getText("wifiCommandError") || "WiFi command error:", error);

        // 恢复按钮状态
        confirmBtn.textContent = originalText;
        confirmBtn.disabled = false;

        // 显示错误消息
        showNotification(getText("wifiCommandFailed") || "Failed to send WiFi configuration. Please check your serial connection.", 'error');
      }
    }





    // 测试串口选择窗口居中显示
    function testPortSelectorCentering()
    {
      console.log("Testing port selector centering...");

      // 创建测试端口数据
      const testPorts = [
        { getInfo: () => ({ usbVendorId: 0x1a86, usbProductId: 0x7523 }) },
        { getInfo: () => ({ usbVendorId: 0x10c4, usbProductId: 0xea60 }) }
      ];

      // 显示测试对话框
      createESP32PortSelector(testPorts).then(port =>
      {
        console.log("Test port selected:", port);
      }).catch(error =>
      {
        console.log("Test cancelled or failed:", error);
      });
    }

    // 显示自定义警告窗口
    function showCustomAlert(message, title = null)
    {
      return new Promise((resolve) =>
      {
        // 创建遮罩层
        const overlay = document.createElement('div');
        overlay.className = 'alert-overlay';

        // 创建对话框
        const dialog = document.createElement('div');
        dialog.className = 'alert-dialog';

        // 处理换行符，将\n转换为<br>标签
        const formattedMessage = message.replace(/\n/g, '<br>');

        // 直接设置内容，避免innerHTML的性能开销
        const h3 = document.createElement('h3');
        h3.textContent = title || getText("error");

        const p = document.createElement('p');
        p.innerHTML = formattedMessage;

        const button = document.createElement('button');
        button.textContent = getText("ok");
        button.onclick = () =>
        {
          document.body.removeChild(overlay);
          resolve();
        };

        dialog.appendChild(h3);
        dialog.appendChild(p);
        dialog.appendChild(button);

        // 将对话框添加到遮罩层中
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
      });
    }

    // 添加串口消息到监视器
    function addSerialMessage(message)
    {
      const outputDiv = document.getElementById('serialOutput');
      if (!outputDiv) return;

      const currentTime = Date.now();

      // 创建时间戳容器
      const timestampSpan = document.createElement('span');
      timestampSpan.className = 'timestamp';
      timestampSpan.textContent = showSerialTimestamp ? `${getFormattedTimestamp()} ` : '';
      timestampSpan.style.display = showSerialTimestamp ? 'inline' : 'none';
      timestampSpan.style.color = '#888';
      timestampSpan.style.fontWeight = 'normal';

      // 创建消息内容容器
      const messageSpan = document.createElement('span');
      messageSpan.className = 'message-content';
      messageSpan.textContent = message;
      messageSpan.style.color = '#fff';

      // 创建容器div
      const lineDiv = document.createElement('div');
      lineDiv.style.padding = '3px 0';
      lineDiv.style.marginBottom = '3px';
      lineDiv.style.fontSize = '13px';
      lineDiv.style.whiteSpace = 'nowrap';
      lineDiv.style.lineHeight = '1.3';

      // 将时间戳和消息添加到容器中
      lineDiv.appendChild(timestampSpan);
      lineDiv.appendChild(messageSpan);

      outputDiv.appendChild(lineDiv);

      // 滚动到底部
      outputDiv.scrollTop = outputDiv.scrollHeight;

      // 更新最后消息时间
      lastSerialMessageTime = currentTime;
    }



    // 验证串口连接 - 发送'?'字符并检查回复
    async function validateSerialConnection()
    {
      try
      {
        // 清空之前的缓冲区
        serialBufferText = '';
        serialBuffer = '';

        // 发送'?'字符
        const encoder = new TextEncoder();
        const data = encoder.encode('?');
        await writer.write(data);
        console.log(getText("sentValidationCommand"));

        // 根据操作系统设置等待时间
        const os = OPERATING_SYSTEM;
        const waitTime = (os === 'windows') ? TIMEOUT_CONFIG.UI.VALIDATION_TIMEOUT_WINDOWS : TIMEOUT_CONFIG.UI.VALIDATION_TIMEOUT_OTHER; // 使用配置的验证超时时间

        const startTime = Date.now();
        let response = '';
        let validationTimeout = false;

        // 设置超时时间
        const timeoutPromise = new Promise((resolve) =>
        {
          setTimeout(() =>
          {
            validationTimeout = true;
            resolve();
          }, waitTime);
        });

        // 等待回复或超时
        const responsePromise = new Promise(async (resolve) =>
        {
          while (!validationTimeout && Date.now() - startTime < waitTime)
          {
            try
            {
              const { value, done } = await reader.read();
              if (done) break;

              const text = new TextDecoder().decode(value);
              response += text;

              // 检查是否包含Petoi设备标识
              if (response.includes('Bittle') || response.includes('Nybble') || response.includes('Petoi') || response.includes('Chero'))
              {
                // 提取设备型号信息用于控制台显示
                const cleanResponse = response.replace(/[\r\n?]+/g, ' ').trim();
                const modelInfo = cleanResponse.replace(/\s*\?\s*$/, '').trim();
                console.log(getText("model") + ":", modelInfo);

                resolve(true);
                return;
              }

              // 如果已经超过等待时间，停止等待
              if (Date.now() - startTime >= waitTime)
              {
                break;
              }
            } catch (error)
            {
              console.warn("Error reading during validation:", error);
              break;
            }
          }
          resolve(false);
        });

        // 等待第一个完成的Promise
        const result = await Promise.race([responsePromise, timeoutPromise]);

        if (validationTimeout)
        {
          console.log(getText("serialValidationTimeout"));
          return false;
        }

        return result;
      } catch (error)
      {
        console.error(getText("serialValidationError"), error);
        return false;
      }
    }

    async function readSerialData()
    {
      try
      {
        while (true)
        {
          const { value, done } = await reader.read();
          if (done)
          {
            reader.releaseLock();
            break;
          }
          const text = new TextDecoder().decode(value);
          if (!text) continue; // 如果没有数据，跳过
          serialBufferText += text;
          const lastLineIndex = serialBufferText.lastIndexOf('\r\n');
          const linesText = serialBufferText.substring(0, lastLineIndex) + '\r\n';
          const lines = linesText.split('\r\n');
          serialBufferText = serialBufferText.substring(lastLineIndex + 2); // 保留剩余部分
          serialBuffer += text; // 添加到serialBuffer

          // 监听特定格式的输出：类似 "=\r\n4894\r\nR\r\n" 的格式
          // 改进的数据解析逻辑，防止数据分割问题
          const patternMatch = linesText.match(/=\r\n([^\r\n]+)\r\n[a-zA-Z]{1}\r\n/);
          if (patternMatch)
          {
            // 提取第二行内容（第一行是"="，第二行是数字，第三行是"R"）
            const secondLine = patternMatch[1];

            // 验证数据完整性：确保是纯数字
            if (/^\d+$/.test(secondLine))
            {
              addConsoleMessage(secondLine);
            } else
            {
              console.warn('检测到不完整的传感器数据:', secondLine);
              // 不输出不完整的数据，等待完整数据包
            }
          }

          // 改进的缓冲区管理，防止内存泄漏和数据丢失
          if (serialBuffer.length > 20000) // 增加缓冲区大小
          {
            // 保留最后10000个字符，确保不丢失重要数据
            serialBuffer = serialBuffer.substring(serialBuffer.length - 10000);
            console.warn('串口缓冲区已清理，保留最新数据');
          }

          for (let line of lines.reverse())
          {
            // 检查是否找到"IP Address:"字符串
            const ipAddressPosition = line.indexOf("IP Address:");
            const afterPrefix = line.substring(ipAddressPosition).trim();
            const possibleIPMatch = afterPrefix.match(/^IP Address:\s*(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$/);
            if (possibleIPMatch)
            {
              // 取消任何正在进行的IP检查定时器
              if (ipCheckTimer)
              {
                clearTimeout(ipCheckTimer);
                ipCheckTimer = null;
              }

              const possibleIP = possibleIPMatch[1];
              // 延迟处理IP地址，等待可能的后续数据片段
              lastPartialIP = possibleIP;

              // 设置延迟处理定时器 (100ms)
              ipCheckTimer = setTimeout(() =>
              {
                processDetectedIP(lastPartialIP);
                ipCheckTimer = null;
                lastPartialIP = null;
              }, TIMEOUT_CONFIG.UI.IP_CHECK_DELAY);
              break; // 找到IP地址后跳出循环
            }
          }

          // 将数据添加到缓冲区
          serialOutputBuffer += text;

          // 检查缓冲区中是否包含换行符
          if (serialOutputBuffer.includes('\n'))
          {
            // 如果有换行符，立即处理到换行符为止的数据
            processSerialOutputBufferWithNewlines();
          } else
          {
            // 如果没有换行符，使用延时缓冲
            if (serialOutputTimer)
            {
              clearTimeout(serialOutputTimer);
            }
            serialOutputTimer = setTimeout(() =>
            {
              processSerialOutputBuffer();
            }, TIMEOUT_CONFIG.UI.SERIAL_OUTPUT_BUFFER_DELAY);
          }
        }
      } catch (error)
      {
        console.error(getText("serialReadError"), error);

        // 检测硬件断开连接
        if (error.name === 'NetworkError' ||
          error.message.includes('failed to read') ||
          error.message.includes('device disconnected') ||
          error.message.includes('connection lost'))
        {
          console.log(getText('hardwareDisconnected'));

          // 重置串口相关变量
          reader = null;
          writer = null;
          port = null;

          // 更新UI状态，隐藏串口界面
          const serialInterface = document.getElementById('serialInterface');
          if (serialInterface)
          {
            serialInterface.style.display = 'none';
          }

          // 移除connected类，恢复串口容器默认样式
          const serialContainer = document.getElementById('serialContainer');
          if (serialContainer)
          {
            serialContainer.classList.remove('connected');
          }

          // 隐藏分隔线
          const divider = document.getElementById('console-serial-divider');
          if (divider)
          {
            divider.style.display = 'none';
          }

          // 调整控制台和串口区域的比例
          const consoleWindow = document.getElementById('consoleWindow');
          if (consoleWindow)
          {
            consoleWindow.style.flex = '90';
          }
          if (serialContainer)
          {
            serialContainer.style.flex = '10';
          }

          // 更新按钮状态
          const openSerialBtn = document.getElementById('openSerialBtn');
          const showSerialTimestampBtn = document.getElementById('showSerialTimestampBtn');
          const closeSerialBtn = document.getElementById('closeSerialBtn');
          const clearSerialBtn = document.getElementById('clearSerialBtn');

          if (openSerialBtn) openSerialBtn.style.display = 'inline-flex';
          if (showSerialTimestampBtn) showSerialTimestampBtn.style.display = 'none';
          if (closeSerialBtn) closeSerialBtn.style.display = 'none';
          if (clearSerialBtn) clearSerialBtn.style.display = 'none';

          // 重置串口监视器标题
          const serialTitle = document.getElementById('serialOutputTitle');
          if (serialTitle)
          {
            serialTitle.textContent = getText("serialOutput");
          }

          // 只有在没有WebSocket连接时才重置Quick Connect按钮
          // 如果有currentDeviceIP，说明可能还有WebSocket连接，不重置按钮
          if (!currentDeviceIP || currentDeviceIP === '192.168.4.1')
          {
            resetQuickConnectButton();
            if (typeof showDebug !== 'undefined' && showDebug)
            {
              console.log('Reset Quick Connect button (no WebSocket connection)');
            }
          } else
          {
            // 如果有IP地址，保持按钮显示IP
            updateQuickConnectButtonState(currentDeviceIP);
            if (typeof showDebug !== 'undefined' && showDebug)
            {
              console.log(`Kept Quick Connect button showing IP: ${currentDeviceIP}`);
            }
          }

          // 强制重新调整工作区大小
          setTimeout(function ()
          {
            resizeBlocklyWorkspace();
            repositionUndoRedoButtons();
          }, 100);

          console.log(getText('serialConnectionCleanupCompleted'));
        }
      }
    }

    // 处理串口输出缓冲区（带换行符的智能处理）
    function processSerialOutputBufferWithNewlines()
    {
      if (!serialOutputBuffer.trim())
      {
        return;
      }

      const outputDiv = document.getElementById('serialOutput');
      const showSerialTimestamp = document.getElementById('showSerialTimestampBtn').classList.contains('active');
      const currentTime = Date.now();
      const timeSinceLastMessage = currentTime - lastSerialMessageTime;

      // 找到第一个换行符的位置
      const newlineIndex = serialOutputBuffer.indexOf('\n');
      if (newlineIndex === -1)
      {
        return; // 没有换行符，不应该调用这个函数
      }

      // 提取到换行符为止的完整消息
      const completeMessage = serialOutputBuffer.substring(0, newlineIndex + 1);
      // 保留剩余的数据
      serialOutputBuffer = serialOutputBuffer.substring(newlineIndex + 1);

      // 检查是否需要添加换行符（如果离上次收到消息超过100ms）
      const needNewLine = timeSinceLastMessage > 100;

      // 如果时间间隔超过100ms，添加换行符
      if (needNewLine)
      {
        outputDiv.appendChild(document.createElement('br'));
      }

      // 处理完整消息
      const lines = completeMessage.split('\n');
      let isFirstLine = true;

      lines.forEach((line, index) =>
      {
        // 跳过空行
        if (line.trim() === '' && index === lines.length - 1)
        {
          return;
        }

        // 检查是否需要添加timestamp
        let needTimestamp = false;
        if (isFirstLine)
        {
          // 第一行：总是添加timestamp（新消息的开始）
          needTimestamp = true;
          isFirstLine = false;
        } else
        {
          // 后续行：如果换行后要显示的是可显示字符，则加timestamp
          needTimestamp = line.trim().length > 0;
        }

        if (line.trim() !== '')
        {
          // 创建时间戳容器
          const timestampSpan = document.createElement('span');
          timestampSpan.className = 'timestamp';
          timestampSpan.textContent = needTimestamp ? `${getFormattedTimestamp()} ` : '';
          timestampSpan.style.display = (showSerialTimestamp && needTimestamp) ? 'inline' : 'none';
          timestampSpan.style.color = '#888';
          timestampSpan.style.fontWeight = 'normal';

          // 创建消息内容容器
          const messageSpan = document.createElement('span');
          messageSpan.className = 'message-content';
          messageSpan.textContent = line;
          messageSpan.style.color = '#fff';

          // 创建容器div
          const lineDiv = document.createElement('div');
          lineDiv.style.padding = '3px 0';
          lineDiv.style.marginBottom = '3px';
          lineDiv.style.fontSize = '13px';
          lineDiv.style.whiteSpace = 'nowrap';
          lineDiv.style.lineHeight = '1.3';

          // 将时间戳和消息添加到容器中
          lineDiv.appendChild(timestampSpan);
          lineDiv.appendChild(messageSpan);

          outputDiv.appendChild(lineDiv);

          // 每换行一次就重置时间，避免累积导致错误换行
          lastSerialMessageTime = currentTime;
        }
      });

      // 立即滚动到底部
      outputDiv.scrollTop = outputDiv.scrollHeight;
      // 强制DOM重绘
      void outputDiv.offsetHeight;

      // 如果缓冲区中还有数据，继续处理
      if (serialOutputBuffer.includes('\n'))
      {
        processSerialOutputBufferWithNewlines();
      }
    }

    // 处理串口输出缓冲区（延时处理）
    function processSerialOutputBuffer()
    {
      if (!serialOutputBuffer.trim())
      {
        return;
      }

      const outputDiv = document.getElementById('serialOutput');
      const showSerialTimestamp = document.getElementById('showSerialTimestampBtn').classList.contains('active');
      const currentTime = Date.now();
      const timeSinceLastMessage = currentTime - lastSerialMessageTime;

      // 检查是否需要添加换行符（如果离上次收到消息超过100ms）
      const needNewLine = timeSinceLastMessage > 100;

      // 如果时间间隔超过100ms，添加换行符
      if (needNewLine)
      {
        outputDiv.appendChild(document.createElement('br'));
      }

      // 处理文本内容，正确处理换行符
      const textLines = serialOutputBuffer.split('\n');
      let isFirstLine = true;

      textLines.forEach((line, index) =>
      {
        // 跳过空行
        if (line.trim() === '' && index === textLines.length - 1)
        {
          return;
        }

        // 检查是否需要添加timestamp
        let needTimestamp = false;
        if (isFirstLine)
        {
          // 第一行：总是添加timestamp（新消息的开始）
          needTimestamp = true;
          isFirstLine = false;
        } else
        {
          // 后续行：如果换行后要显示的是可显示字符，则加timestamp
          needTimestamp = line.trim().length > 0;
        }

        if (line.trim() !== '')
        {
          // 创建时间戳容器
          const timestampSpan = document.createElement('span');
          timestampSpan.className = 'timestamp';
          timestampSpan.textContent = needTimestamp ? `${getFormattedTimestamp()} ` : '';
          timestampSpan.style.display = (showSerialTimestamp && needTimestamp) ? 'inline' : 'none';
          timestampSpan.style.color = '#888';
          timestampSpan.style.fontWeight = 'normal';

          // 创建消息内容容器
          const messageSpan = document.createElement('span');
          messageSpan.className = 'message-content';
          messageSpan.textContent = line;
          messageSpan.style.color = '#fff';

          // 创建容器div
          const lineDiv = document.createElement('div');
          lineDiv.style.padding = '3px 0';
          lineDiv.style.marginBottom = '3px';
          lineDiv.style.fontSize = '13px';
          lineDiv.style.whiteSpace = 'nowrap';
          lineDiv.style.lineHeight = '1.3';

          // 将时间戳和消息添加到容器中
          lineDiv.appendChild(timestampSpan);
          lineDiv.appendChild(messageSpan);

          outputDiv.appendChild(lineDiv);

          // 每换行一次就重置时间，避免累积导致错误换行
          lastSerialMessageTime = currentTime;
        }
      });

      // 清空缓冲区
      serialOutputBuffer = '';

      // 立即滚动到底部
      outputDiv.scrollTop = outputDiv.scrollHeight;
      // 强制DOM重绘
      void outputDiv.offsetHeight;
    }

    // 处理检测到的IP地址
    async function processDetectedIP(ip)
    {
      if (!ip) return;

      // 验证IP地址格式是否合法
      const ipSegments = ip.split('.');
      if (ipSegments.length === 4 && ipSegments.every(segment =>
      {
        // 检查每段是否为有效数字且在0-255范围内
        const num = parseInt(segment, 10);
        return !isNaN(num) && num >= 0 && num <= 255;
      }))
      {
        // IP地址格式完整且合法，可以安全使用

        // 检查是否为新的IP地址
        if (currentDeviceIP !== ip)
        {
          console.log(getText("newIPDetected").replace("{ip}", ip).replace("{oldIP}", currentDeviceIP));

          // 保存设备IP到全局变量
          currentDeviceIP = ip;

          // 修改Quick Connect按钮样式和文本
          updateQuickConnectButtonState(ip);

          // 查找工作区中的make_connection积木块并更新IP地址
          const makeConnectionBlocks = workspace.getBlocksByType('make_connection');
          if (makeConnectionBlocks && makeConnectionBlocks.length > 0)
          {
            // 更新第一个make_connection积木块的IP_ADDRESS字段
            makeConnectionBlocks[0].setFieldValue(ip, 'IP_ADDRESS');
          }

          // 如果获取到IP地址，关闭可能存在的WiFi配置对话框
          closeWifiDialog();

          // 保存到配置文件
          await saveConfig();
        }
      } else
      {
        console.log(getText("invalidIPFormat").replace("{ip}", ip));
      }
    }

    async function sendSerialData()
    {
      if (!writer) return;

      const input = document.getElementById('serialInput');
      // 检查输入是否为空
      if (input.value.trim() === '') return;

      const data = input.value + '\n';

      try
      {
        await writer.write(new TextEncoder().encode(data));

        // 添加命令到历史记录
        if (input.value.trim() !== '')
        {
          // 避免重复添加相同的命令
          if (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== input.value)
          {
            commandHistory.push(input.value);
          }
          // 保持历史记录在合理范围内(最多保存50条)
          if (commandHistory.length > 50)
          {
            commandHistory.shift();
          }
          // 重置历史索引
          historyIndex = -1;
          tempInputValue = '';
        }

        input.value = '';
      } catch (error)
      {
        console.error(getText("serialSendError"), error);
      }
    }

    function clearSerialOutput()
    {
      const outputDiv = document.getElementById('serialOutput');
      outputDiv.innerHTML = '';
      // 重置缓冲区
      serialBufferText = '';
      serialBuffer = '';
      serialOutputBuffer = '';
      // 重置时间变量
      lastSerialMessageTime = 0;
      // 清除定时器
      if (serialOutputTimer)
      {
        clearTimeout(serialOutputTimer);
        serialOutputTimer = null;
      }
    }

    // 添加回车键发送功能
    document.getElementById('serialInput').addEventListener('keypress', function (e)
    {
      if (e.key === 'Enter')
      {
        sendSerialData();
      }
    });

    // 添加上下箭头键历史命令功能
    document.getElementById('serialInput').addEventListener('keydown', function (e)
    {
      // 上箭头键
      if (e.key === 'ArrowUp')
      {
        e.preventDefault(); // 防止光标移到文本开头

        if (commandHistory.length > 0)
        {
          // 如果是第一次按上箭头，保存当前输入的内容
          if (historyIndex === -1)
          {
            tempInputValue = this.value;
          }

          // 向上浏览历史
          historyIndex = Math.min(historyIndex + 1, commandHistory.length - 1);
          this.value = commandHistory[commandHistory.length - 1 - historyIndex];
        }
      }
      // 下箭头键
      else if (e.key === 'ArrowDown')
      {
        e.preventDefault(); // 防止光标移到文本末尾

        if (historyIndex > 0)
        {
          // 向下浏览历史
          historyIndex--;
          this.value = commandHistory[commandHistory.length - 1 - historyIndex];
        }
        else if (historyIndex === 0)
        {
          // 回到临时保存的输入
          historyIndex = -1;
          this.value = tempInputValue;
        }
      }
    });

    // 添加撤销和重做按钮
    function addUndoRedoButtons()
    {
      // 检查是否已存在按钮，如果存在则移除
      const existingControls = document.querySelector('.undoRedoControls');
      if (existingControls)
      {
        existingControls.remove();
      }

      // 创建包含按钮的div
      const undoRedoControls = document.createElement('div');
      undoRedoControls.className = 'undoRedoControls';

      // 创建撤销按钮
      const undoButton = document.createElement('button');
      undoButton.className = 'undoRedoButton';
      undoButton.id = 'undoButton';
      undoButton.title = getText('undo');
      undoButton.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M9 14L4 9l5-5"/>
          <path d="M4 9h13c2.5 0 4 2 4 4s-1.5 4-4 4H8"/>
        </svg>
      `;
      undoButton.onclick = function ()
      {
        if (workspace.undoStack_ && workspace.undoStack_.length > 0)
        {
          workspace.undo(false);
          updateUndoRedoState();
        }
      };

      // 创建重做按钮
      const redoButton = document.createElement('button');
      redoButton.className = 'undoRedoButton';
      redoButton.id = 'redoButton';
      redoButton.title = getText('redo');
      redoButton.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M15 14l5-5-5-5"/>
          <path d="M20 9H7c-2.5 0-4 2-4 4s1.5 4 4 4h9"/>
        </svg>
      `;
      redoButton.onclick = function ()
      {
        if (workspace.redoStack_ && workspace.redoStack_.length > 0)
        {
          workspace.undo(true);
          updateUndoRedoState();
        }
      };

      // 将按钮添加到控件容器
      undoRedoControls.appendChild(undoButton);
      undoRedoControls.appendChild(redoButton);

      // 将控件容器添加到body
      document.body.appendChild(undoRedoControls);

      // 确保按钮是可见的
      undoRedoControls.style.display = 'flex';

      // 尝试初次定位按钮
      repositionUndoRedoButtons();

      // 再尝试几次定位，确保即使DOM渲染有延迟也能正确显示
      setTimeout(repositionUndoRedoButtons, 500);
      setTimeout(repositionUndoRedoButtons, 1000);

      // 初始化按钮状态
      updateUndoRedoState();
    }

    // 更新撤销和重做按钮状态
    function updateUndoRedoState()
    {
      const undoButton = document.getElementById('undoButton');
      const redoButton = document.getElementById('redoButton');

      if (undoButton && redoButton)
      {
        // 修复hasUndo和hasRedo方法调用，改用undoStack_和redoStack_属性判断
        const canUndo = workspace.undoStack_ && workspace.undoStack_.length > 0;
        const canRedo = workspace.redoStack_ && workspace.redoStack_.length > 0;

        undoButton.disabled = !canUndo;
        redoButton.disabled = !canRedo;

        // 更新按钮标题语言
        undoButton.title = getText('undo');
        redoButton.title = getText('redo');
      }
    }

    // 添加分隔线拖动功能
    document.addEventListener('DOMContentLoaded', function ()
    {
      // 获取所有需要的DOM元素
      const horizontalDivider = document.getElementById('console-serial-divider');
      const divider = document.getElementById('divider');
      const container = document.querySelector('.workspace-container');
      const blocklyDiv = document.getElementById('blocklyDiv');
      const windowsContainer = document.querySelector('.windows-container');
      const consoleWindow = document.getElementById('consoleWindow');
      const serialContainer = document.getElementById('serialContainer');

      // 确保分隔线初始隐藏
      if (horizontalDivider)
      {
        horizontalDivider.style.display = 'none';
      }

      // 设置初始的控制台和串口区域比例
      // 控制台占据大部分空间，串口区域只占据底部一小部分
      consoleWindow.style.flex = '90';
      serialContainer.style.flex = '10';

      // 初始化debug开关状态
      const debugBtn = document.getElementById('showDebugBtn');
      if (debugBtn)
      {
        showDebug = debugBtn.classList.contains('active');
      }

      let isResizing = false;
      let initialX, initialWidth;

      divider.addEventListener('mousedown', function (e)
      {
        // 启动调整大小
        isResizing = true;
        initialX = e.clientX;
        initialWidth = blocklyDiv.getBoundingClientRect().width;

        // 添加调整中的样式
        container.classList.add('resizing');
        divider.classList.add('active');

        // 阻止默认行为，确保拖动正常工作
        e.preventDefault();
      });

      document.addEventListener('mousemove', function (e)
      {
        if (!isResizing) return;

        // 计算移动距离
        const deltaX = e.clientX - initialX;

        // 计算容器总宽度
        const containerWidth = container.getBoundingClientRect().width;

        // 计算新的blocklyDiv宽度 (百分比)
        let newWidthPercent = ((initialWidth + deltaX) / containerWidth) * 100;

        // 确保合理范围 (20% - 80%)
        newWidthPercent = Math.max(20, Math.min(80, newWidthPercent));

        // 应用新宽度 - 同时设置flexBasis和width属性
        blocklyDiv.style.flexBasis = `${newWidthPercent}% `;
        blocklyDiv.style.width = `${newWidthPercent}% `;
        windowsContainer.style.flexBasis = `${99 - newWidthPercent}% `;
        windowsContainer.style.width = `${99 - newWidthPercent}% `;

        // 调整Blockly工作区大小以适应新尺寸
        if (workspace)
        {
          Blockly.svgResize(workspace);
        }

        // 更新undo/redo按钮位置
        repositionUndoRedoButtons();

        // 阻止默认行为
        e.preventDefault();
      });

      document.addEventListener('mouseup', function ()
      {
        if (isResizing)
        {
          // 停止调整大小
          isResizing = false;

          // 移除调整中的样式
          container.classList.remove('resizing');
          divider.classList.remove('active');

          // 确保Blockly工作区尺寸正确
          if (workspace)
          {
            Blockly.svgResize(workspace);
          }
        }

        // 同时处理垂直调整的停止
        if (isVerticalResizing)
        {
          // 停止垂直调整
          isVerticalResizing = false;

          // 移除调整中的样式
          horizontalDivider.classList.remove('active');
          document.body.style.cursor = '';
        }
      });

      // 添加垂直分隔线拖动功能
      let isVerticalResizing = false;
      let initialY, initialConsoleHeight;

      // 确保分隔线存在
      if (horizontalDivider)
      {
        horizontalDivider.addEventListener('mousedown', function (e)
        {
          // 启动垂直调整
          isVerticalResizing = true;
          initialY = e.clientY;
          initialConsoleHeight = consoleWindow.getBoundingClientRect().height;

          // 添加调整中的样式
          horizontalDivider.classList.add('active');
          document.body.style.cursor = 'row-resize';

          // 阻止事件冒泡和默认行为
          e.stopPropagation();
          e.preventDefault();
        });
      }

      // 扩展现有的mousemove事件处理程序，处理垂直调整
      document.addEventListener('mousemove', function (e)
      {
        // 处理垂直调整
        if (isVerticalResizing && horizontalDivider)
        {
          // 计算移动距离
          const deltaY = e.clientY - initialY;

          // 获取windows-container的总高度
          const containerHeight = windowsContainer.getBoundingClientRect().height;

          // 计算新的控制台高度百分比
          let newConsoleHeightPercent = ((initialConsoleHeight + deltaY) / containerHeight) * 100;

          // 确保合理范围 (20% - 80%)
          newConsoleHeightPercent = Math.max(20, Math.min(80, newConsoleHeightPercent));

          // 应用新高度比例
          consoleWindow.style.flex = `${newConsoleHeightPercent} `;
          serialContainer.style.flex = `${100 - newConsoleHeightPercent - 1}`;  // 减去分隔线高度

          // 更新undo/redo按钮位置
          repositionUndoRedoButtons();

          // 阻止事件继续传播和默认行为
          e.stopPropagation();
          e.preventDefault();
        }
      });
    });

  </script>
</body>

</html>
